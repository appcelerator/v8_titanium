diff --git a/include/libplatform/libplatform.h b/include/libplatform/libplatform.h
index 00de81df88..f519aecbdf 100644
--- a/include/libplatform/libplatform.h
+++ b/include/libplatform/libplatform.h
@@ -54,6 +54,13 @@ NewSingleThreadedDefaultPlatform(
         InProcessStackDumping::kDisabled,
     std::unique_ptr<v8::TracingController> tracing_controller = {});
 
+V8_PLATFORM_EXPORT v8::Platform* CreateDefaultPlatform(
+    int thread_pool_size = 0,
+    IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,
+    InProcessStackDumping in_process_stack_dumping =
+        InProcessStackDumping::kDisabled,
+    v8::TracingController* tracing_controller = nullptr);
+
 /**
  * Returns a new instance of the default v8::JobHandle implementation.
  *
diff --git a/include/v8-internal.h b/include/v8-internal.h
index 8abbcfb416..728be2a261 100644
--- a/include/v8-internal.h
+++ b/include/v8-internal.h
@@ -203,8 +203,10 @@ class Internals {
 
   // IsolateData layout guarantees.
   static const int kIsolateEmbedderDataOffset = 0;
-  static const int kIsolateFastCCallCallerFpOffset =
+  static const int kCompatibilityPaddingOffset =
       kNumIsolateDataSlots * kApiSystemPointerSize;
+  static const int kIsolateFastCCallCallerFpOffset =
+      kCompatibilityPaddingOffset + (kApiInt64Size * 3);
   static const int kIsolateFastCCallCallerPcOffset =
       kIsolateFastCCallCallerFpOffset + kApiSystemPointerSize;
   static const int kIsolateFastApiCallTargetOffset =
@@ -232,6 +234,9 @@ class Internals {
   static const int kNodeStateMask = 0x7;
   static const int kNodeStateIsWeakValue = 2;
   static const int kNodeStateIsPendingValue = 3;
+  static const int kNodeStateIsNearDeathValue = 4;
+  static const int kNodeIsIndependentShift = 3;
+  static const int kNodeIsActiveShift = 4;
 
   static const int kFirstNonstringType = 0x40;
   static const int kOddballType = 0x43;
diff --git a/include/v8.h b/include/v8.h
index 7cb19bbede..02ba32837d 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -136,6 +136,7 @@ class HeapObject;
 class Isolate;
 class LocalEmbedderHeapTracer;
 class MicrotaskQueue;
+class Object;
 class PropertyCallbackArguments;
 class ReadOnlyHeap;
 class ScopedExternalStringLock;
@@ -596,6 +597,11 @@ template <class T> class PersistentBase {
    */
   V8_INLINE uint16_t WrapperClassId() const;
 
+  V8_INLINE void MarkIndependent();
+  V8_INLINE void MarkActive();
+  V8_INLINE bool IsIndependent() const;
+  V8_INLINE bool IsNearDeath() const;
+
   PersistentBase(const PersistentBase& other) = delete;  // NOLINT
   void operator=(const PersistentBase&) = delete;
 
@@ -1223,6 +1229,9 @@ class V8_EXPORT V8_NODISCARD HandleScope {
   static internal::Address* CreateHandle(internal::Isolate* isolate,
                                          internal::Address value);
 
+  static internal::Object** CreateHandle(internal::Isolate* isolate,
+                                         internal::Object* value);
+
  private:
   // Declaring operator new and delete as deleted is not spec compliant.
   // Therefore declare them private instead to disable dynamic alloc
@@ -1259,8 +1268,8 @@ class V8_EXPORT V8_NODISCARD EscapableHandleScope : public HandleScope {
    */
   template <class T>
   V8_INLINE Local<T> Escape(Local<T> value) {
-    internal::Address* slot =
-        Escape(reinterpret_cast<internal::Address*>(*value));
+    internal::Object** slot =
+        Escape(reinterpret_cast<internal::Object**>(*value));
     return Local<T>(reinterpret_cast<T*>(slot));
   }
 
@@ -1280,6 +1289,7 @@ class V8_EXPORT V8_NODISCARD EscapableHandleScope : public HandleScope {
   void operator delete(void*, size_t);
   void operator delete[](void*, size_t);
 
+  internal::Object** Escape(internal::Object** escape_value);
   internal::Address* Escape(internal::Address* escape_value);
   internal::Address* escape_slot_;
 };
@@ -1779,12 +1789,16 @@ class V8_EXPORT Script {
       Local<Context> context, Local<String> source,
       ScriptOrigin* origin = nullptr);
 
+  static V8_WARN_UNUSED_RESULT Local<Script> Compile(v8::Local<String> source, v8::ScriptOrigin* origin);
+  static V8_WARN_UNUSED_RESULT Local<Script> Compile(v8::Local<String> source, v8::Local<String> file_name);
+
   /**
    * Runs the script returning the resulting value. It will be run in the
    * context in which it was created (ScriptCompiler::CompileBound or
    * UnboundScript::BindToCurrentContext()).
    */
   V8_WARN_UNUSED_RESULT MaybeLocal<Value> Run(Local<Context> context);
+  Local<Value> Run();
 
   /**
    * Returns the corresponding context-unbound script.
@@ -2241,6 +2255,9 @@ class V8_EXPORT Message {
   // TODO(1245381): Print to a string instead of on a FILE.
   static void PrintCurrentStackTrace(Isolate* isolate, FILE* out);
 
+  V8_WARN_UNUSED_RESULT Local<String> GetSourceLine() const;
+  int GetLineNumber() const;
+
   static const int kNoLineNumberInfo = 0;
   static const int kNoColumnInfo = 0;
   static const int kNoScriptIdInfo = 0;
@@ -3049,6 +3066,11 @@ class V8_EXPORT Value : public Data {
    * Perform the equivalent of `Boolean(value)` in JS. This can never fail.
    */
   Local<Boolean> ToBoolean(Isolate* isolate) const;
+  Local<Number> ToNumber(Isolate* isolate) const;
+  Local<String> ToString(Isolate* isolate) const;
+  Local<Object> ToObject(Isolate* isolate) const;
+  Local<Integer> ToInteger(Isolate* isolate) const;
+  Local<Int32> ToInt32(Isolate* isolate) const;
 
   /**
    * Attempts to convert a string to an array index.
@@ -3059,6 +3081,8 @@ class V8_EXPORT Value : public Data {
 
   /** Returns the equivalent of `ToBoolean()->Value()`. */
   bool BooleanValue(Isolate* isolate) const;
+  MaybeLocal<Boolean> ToBoolean(Local<Context> context) const;
+  Maybe<bool> BooleanValue(Local<Context> context) const;
 
   /** Returns the equivalent of `ToNumber()->Value()`. */
   V8_WARN_UNUSED_RESULT Maybe<double> NumberValue(Local<Context> context) const;
@@ -3261,16 +3285,7 @@ class V8_EXPORT String : public Name {
    public:
     virtual ~ExternalStringResourceBase() = default;
 
-    /**
-     * If a string is cacheable, the value returned by
-     * ExternalStringResource::data() may be cached, otherwise it is not
-     * expected to be stable beyond the current top-level task.
-     */
-    virtual bool IsCacheable() const { return true; }
-
-    // Disallow copying and assigning.
-    ExternalStringResourceBase(const ExternalStringResourceBase&) = delete;
-    void operator=(const ExternalStringResourceBase&) = delete;
+    virtual bool IsCompressible() const { return false; }
 
    protected:
     ExternalStringResourceBase() = default;
@@ -3283,28 +3298,9 @@ class V8_EXPORT String : public Name {
      */
     virtual void Dispose() { delete this; }
 
-    /**
-     * For a non-cacheable string, the value returned by
-     * |ExternalStringResource::data()| has to be stable between |Lock()| and
-     * |Unlock()|, that is the string must behave as is |IsCacheable()| returned
-     * true.
-     *
-     * These two functions must be thread-safe, and can be called from anywhere.
-     * They also must handle lock depth, in the sense that each can be called
-     * several times, from different threads, and unlocking should only happen
-     * when the balance of Lock() and Unlock() calls is 0.
-     */
-    virtual void Lock() const {}
-
-    /**
-     * Unlocks the string.
-     */
-    virtual void Unlock() const {}
-
    private:
     friend class internal::ExternalString;
     friend class v8::String;
-    friend class internal::ScopedExternalStringLock;
   };
 
   /**
@@ -3433,6 +3429,11 @@ class V8_EXPORT String : public Name {
 
   V8_INLINE static String* Cast(v8::Data* data);
 
+  enum NewStringType {
+    kNormalString = static_cast<int>(v8::NewStringType::kNormal),
+    kInternalizedString = static_cast<int>(v8::NewStringType::kInternalized)
+  };
+
   /**
    * Allocates a new string from a UTF-8 literal. This is equivalent to calling
    * String::NewFromUtf(isolate, "...").ToLocalChecked(), but without the check
@@ -3445,7 +3446,7 @@ class V8_EXPORT String : public Name {
   template <int N>
   static V8_WARN_UNUSED_RESULT Local<String> NewFromUtf8Literal(
       Isolate* isolate, const char (&literal)[N],
-      NewStringType type = NewStringType::kNormal) {
+      v8::NewStringType type = v8::NewStringType::kNormal) {
     static_assert(N <= kMaxLength, "String is too long");
     return NewFromUtf8Literal(isolate, literal, type, N - 1);
   }
@@ -3454,19 +3455,22 @@ class V8_EXPORT String : public Name {
    * length > kMaxLength. **/
   static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromUtf8(
       Isolate* isolate, const char* data,
-      NewStringType type = NewStringType::kNormal, int length = -1);
+      v8::NewStringType type = v8::NewStringType::kNormal, int length = -1);
 
   /** Allocates a new string from Latin-1 data.  Only returns an empty value
    * when length > kMaxLength. **/
   static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromOneByte(
       Isolate* isolate, const uint8_t* data,
-      NewStringType type = NewStringType::kNormal, int length = -1);
+      v8::NewStringType type = v8::NewStringType::kNormal, int length = -1);
 
   /** Allocates a new string from UTF-16 data. Only returns an empty value when
    * length > kMaxLength. **/
   static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromTwoByte(
       Isolate* isolate, const uint16_t* data,
-      NewStringType type = NewStringType::kNormal, int length = -1);
+      v8::NewStringType type = v8::NewStringType::kNormal, int length = -1);
+
+  static Local<String> NewFromUtf8(Isolate* isolate, const char* data, NewStringType type = kNormalString, int length = -1);
+  static Local<String> NewFromTwoByte(Isolate* isolate, const uint16_t* data, NewStringType type = kNormalString, int length = -1);
 
   /**
    * Creates a new string by concatenating the left and the right strings
@@ -3538,6 +3542,7 @@ class V8_EXPORT String : public Name {
    */
   class V8_EXPORT Utf8Value {
    public:
+    Utf8Value(Local<v8::Value> obj);
     Utf8Value(Isolate* isolate, Local<v8::Value> obj);
     ~Utf8Value();
     char* operator*() { return str_; }
@@ -3561,6 +3566,7 @@ class V8_EXPORT String : public Name {
    */
   class V8_EXPORT Value {
    public:
+    Value(Local<v8::Value> obj);
     Value(Isolate* isolate, Local<v8::Value> obj);
     ~Value();
     uint16_t* operator*() { return str_; }
@@ -3586,7 +3592,7 @@ class V8_EXPORT String : public Name {
 
   static Local<v8::String> NewFromUtf8Literal(Isolate* isolate,
                                               const char* literal,
-                                              NewStringType type, int length);
+                                              v8::NewStringType type, int length);
 
   static void CheckCast(v8::Data* that);
 };
@@ -3595,7 +3601,7 @@ class V8_EXPORT String : public Name {
 // terminator).
 template <>
 inline V8_WARN_UNUSED_RESULT Local<String> String::NewFromUtf8Literal(
-    Isolate* isolate, const char (&literal)[1], NewStringType type) {
+    Isolate* isolate, const char (&literal)[1], v8::NewStringType type) {
   return String::Empty(isolate);
 }
 
@@ -4013,6 +4019,12 @@ class V8_EXPORT Object : public Value {
   /**
    * Note: SideEffectType affects the getter only, not the setter.
    */
+  bool SetAccessor(Local<Name> name,
+      AccessorNameGetterCallback getter,
+      AccessorNameSetterCallback setter = 0,
+      Local<Value> data = Local<Value>(),
+      AccessControl settings = DEFAULT,
+      PropertyAttribute attribute = None);
   V8_WARN_UNUSED_RESULT Maybe<bool> SetAccessor(
       Local<Context> context, Local<Name> name,
       AccessorNameGetterCallback getter,
@@ -4372,6 +4384,19 @@ class V8_EXPORT Object : public Value {
    */
   bool IsCodeLike(Isolate* isolate);
 
+  bool Set(Local<Value> key, Local<Value> value);
+  bool Set(uint32_t index, Local<Value> value);
+  Local<Value> Get(Local<Value> key);
+  Local<Value> Get(uint32_t index);
+  Local<Array> GetPropertyNames();
+  Local<Array> GetOwnPropertyNames();
+  Local<Value> GetRealNamedProperty(Local<String> key);
+
+  bool Has(Local<Value> key);
+  bool HasOwnProperty(Local<String> key);
+  bool HasRealNamedProperty(Local<String> key);
+  bool HasRealNamedCallbackProperty(Local<String> key);
+
  private:
   Object();
   static void CheckCast(Value* obj);
@@ -4564,6 +4589,8 @@ class FunctionCallbackInfo {
   // This shouldn't be public, but the arm compiler needs it.
   static const int kArgsLength = 6;
 
+  V8_INLINE Local<Function> Callee() const;
+
  protected:
   friend class internal::FunctionCallbackArguments;
   friend class internal::CustomArguments<FunctionCallbackInfo>;
@@ -4574,6 +4601,7 @@ class FunctionCallbackInfo {
   static const int kReturnValueIndex = 3;
   static const int kDataIndex = 4;
   static const int kNewTargetIndex = 5;
+  static const int kCalleeIndex = 6;
 
   V8_INLINE FunctionCallbackInfo(internal::Address* implicit_args,
                                  internal::Address* values, int length);
@@ -4797,6 +4825,10 @@ class V8_EXPORT Function : public Object {
   V8_INLINE static Function* Cast(Value* obj);
   static const int kLineOffsetNotFound;
 
+  Local<Function> New(Isolate* isolate, FunctionCallback callback, Local<Value> data = Local<Value>(), int length = 0);
+  Local<Value> Call(Local<Value> recv, int argc, Local<Value> argv[]);
+  Local<Object> NewInstance(int argc, Local<Value> argv[]) const;
+
  private:
   Function();
   static void CheckCast(Value* obj);
@@ -6088,6 +6120,8 @@ class V8_EXPORT Date : public Object {
 
   V8_INLINE static Date* Cast(Value* obj);
 
+  static V8_WARN_UNUSED_RESULT Local<Value> New(Isolate* isolate, double time);
+
  private:
   static void CheckCast(Value* obj);
 };
@@ -6376,6 +6410,12 @@ class V8_EXPORT Template : public Data {
   friend class FunctionTemplate;
 };
 
+typedef void (*NamedPropertyGetterCallback)(Local<String> property, const PropertyCallbackInfo<Value>& info);
+typedef void (*NamedPropertySetterCallback)(Local<String> property, Local<Value> value, const PropertyCallbackInfo<Value>& info);
+typedef void (*NamedPropertyQueryCallback)(Local<String> property, const PropertyCallbackInfo<Integer>& info);
+typedef void (*NamedPropertyDeleterCallback)(Local<String> property, const PropertyCallbackInfo<Boolean>& info);
+typedef void (*NamedPropertyEnumeratorCallback)(const PropertyCallbackInfo<Array>& info);
+
 // TODO(dcarney): Replace GenericNamedPropertyFooCallback with just
 // NamedPropertyFooCallback.
 
@@ -6727,8 +6767,13 @@ class V8_EXPORT FunctionTemplate : public Template {
       Isolate* isolate, FunctionCallback callback = nullptr,
       Local<Value> data = Local<Value>(),
       Local<Signature> signature = Local<Signature>(), int length = 0,
-      ConstructorBehavior behavior = ConstructorBehavior::kAllow,
-      SideEffectType side_effect_type = SideEffectType::kHasSideEffect,
+      ConstructorBehavior behavior = ConstructorBehavior::kAllow);
+  static Local<FunctionTemplate> New(
+      Isolate* isolate, FunctionCallback callback,
+      Local<Value> data,
+      Local<Signature> signature, int length,
+      ConstructorBehavior behavior,
+      SideEffectType side_effect_type,
       const CFunction* c_function = nullptr);
 
   /**
@@ -6825,6 +6870,8 @@ class V8_EXPORT FunctionTemplate : public Template {
 
   V8_INLINE static FunctionTemplate* Cast(Data* data);
 
+  Local<Function> GetFunction();
+
  private:
   FunctionTemplate();
 
@@ -7065,10 +7112,24 @@ class V8_EXPORT ObjectTemplate : public Template {
       AccessorNameSetterCallback setter = nullptr,
       Local<Value> data = Local<Value>(), AccessControl settings = DEFAULT,
       PropertyAttribute attribute = None,
-      Local<AccessorSignature> signature = Local<AccessorSignature>(),
-      SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect,
+      Local<AccessorSignature> signature = Local<AccessorSignature>());
+  void SetAccessor(
+      Local<Name> name, AccessorNameGetterCallback getter,
+      AccessorNameSetterCallback setter,
+      Local<Value> data, AccessControl settings,
+      PropertyAttribute attribute,
+      Local<AccessorSignature> signature,
+      SideEffectType getter_side_effect_type,
       SideEffectType setter_side_effect_type = SideEffectType::kHasSideEffect);
 
+  void SetNamedPropertyHandler(
+      NamedPropertyGetterCallback getter,
+      NamedPropertySetterCallback setter = 0,
+      NamedPropertyQueryCallback query = 0,
+      NamedPropertyDeleterCallback deleter = 0,
+      NamedPropertyEnumeratorCallback enumerator = 0,
+      Local<Value> data = Local<Value>());
+
   /**
    * Sets a named property handler on the object template.
    *
@@ -7201,6 +7262,8 @@ class V8_EXPORT ObjectTemplate : public Template {
 
   V8_INLINE static ObjectTemplate* Cast(Data* data);
 
+  Local<Object> NewInstance();
+
  private:
   ObjectTemplate();
   static Local<ObjectTemplate> New(internal::Isolate* isolate,
@@ -7252,6 +7315,19 @@ class V8_EXPORT AccessorSignature : public Data {
 
 
 // --- Extensions ---
+class V8_EXPORT ExternalOneByteStringResourceImpl
+    : public String::ExternalOneByteStringResource {
+ public:
+  ExternalOneByteStringResourceImpl() : data_(nullptr), length_(0) {}
+  ExternalOneByteStringResourceImpl(const char* data, size_t length)
+      : data_(data), length_(length) {}
+  const char* data() const override { return data_; }
+  size_t length() const override { return length_; }
+
+ private:
+  const char* data_;
+  size_t length_;
+};
 
 /**
  * Ignore
@@ -10094,6 +10170,12 @@ class V8_EXPORT V8 {
    */
   static bool Initialize(int build_config);
 
+  static internal::Object** GlobalizeReference(internal::Isolate* isolate, internal::Object** handle);
+  static void DisposeGlobal(internal::Object** global_handle);
+  static void MakeWeak(internal::Object** location, void* data, WeakCallbackInfo<void>::Callback weak_callback, WeakCallbackType type);
+  static void MakeWeak(internal::Object*** location_addr);
+  static void* ClearWeak(internal::Object** location);
+
   static internal::Address* GlobalizeReference(internal::Isolate* isolate,
                                                internal::Address* handle);
   static internal::Address* GlobalizeTracedReference(internal::Isolate* isolate,
@@ -10509,6 +10591,9 @@ class V8_EXPORT TryCatch {
   TryCatch(const TryCatch&) = delete;
   void operator=(const TryCatch&) = delete;
 
+  explicit TryCatch();
+  Local<Value> StackTrace() const;
+
  private:
   // Declaring operator new and delete as deleted is not spec compliant.
   // Therefore declare them private instead to disable dynamic alloc
@@ -11050,7 +11135,7 @@ template <class T>
 Local<T> Local<T>::New(Isolate* isolate, T* that) {
   if (that == nullptr) return Local<T>();
   T* that_ptr = that;
-  internal::Address* p = reinterpret_cast<internal::Address*>(that_ptr);
+  internal::Object** p = reinterpret_cast<internal::Object**>(that_ptr);
   return Local<T>(reinterpret_cast<T*>(HandleScope::CreateHandle(
       reinterpret_cast<internal::Isolate*>(isolate), *p)));
 }
@@ -11093,7 +11178,7 @@ void* WeakCallbackInfo<T>::GetInternalField(int index) const {
 template <class T>
 T* PersistentBase<T>::New(Isolate* isolate, T* that) {
   if (that == nullptr) return nullptr;
-  internal::Address* p = reinterpret_cast<internal::Address*>(that);
+  internal::Object** p = reinterpret_cast<internal::Object**>(that);
   return reinterpret_cast<T*>(
       V8::GlobalizeReference(reinterpret_cast<internal::Isolate*>(isolate),
                              p));
@@ -11123,7 +11208,7 @@ bool PersistentBase<T>::IsWeak() const {
 template <class T>
 void PersistentBase<T>::Reset() {
   if (this->IsEmpty()) return;
-  V8::DisposeGlobal(reinterpret_cast<internal::Address*>(this->val_));
+  V8::DisposeGlobal(reinterpret_cast<internal::Object**>(this->val_));
   val_ = nullptr;
 }
 
@@ -11159,7 +11244,7 @@ V8_INLINE void PersistentBase<T>::SetWeak(
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wcast-function-type"
 #endif
-  V8::MakeWeak(reinterpret_cast<internal::Address*>(this->val_), parameter,
+  V8::MakeWeak(reinterpret_cast<internal::Object**>(this->val_), parameter,
                reinterpret_cast<Callback>(callback), type);
 #if (__GNUC__ >= 8) && !defined(__clang__)
 #pragma GCC diagnostic pop
@@ -11168,14 +11253,14 @@ V8_INLINE void PersistentBase<T>::SetWeak(
 
 template <class T>
 void PersistentBase<T>::SetWeak() {
-  V8::MakeWeak(reinterpret_cast<internal::Address**>(&this->val_));
+  V8::MakeWeak(reinterpret_cast<internal::Object***>(&this->val_));
 }
 
 template <class T>
 template <typename P>
 P* PersistentBase<T>::ClearWeak() {
   return reinterpret_cast<P*>(
-      V8::ClearWeak(reinterpret_cast<internal::Address*>(this->val_)));
+      V8::ClearWeak(reinterpret_cast<internal::Object**>(this->val_)));
 }
 
 template <class T>
@@ -11203,6 +11288,35 @@ uint16_t PersistentBase<T>::WrapperClassId() const {
   return *reinterpret_cast<uint16_t*>(addr);
 }
 
+template <class T>
+void PersistentBase<T>::MarkIndependent() {
+  typedef internal::Internals I;
+  if (this->IsEmpty()) return;
+  I::UpdateNodeFlag(reinterpret_cast<internal::Address*>(this->val_), true, I::kNodeIsIndependentShift);
+}
+
+template <class T>
+void PersistentBase<T>::MarkActive() {
+  typedef internal::Internals I;
+  if (this->IsEmpty()) return;
+  I::UpdateNodeFlag(reinterpret_cast<internal::Address*>(this->val_), true, I::kNodeIsActiveShift);
+}
+
+template <class T>
+bool PersistentBase<T>::IsIndependent() const {
+  typedef internal::Internals I;
+  if (this->IsEmpty()) return false;
+  return I::GetNodeFlag(reinterpret_cast<internal::Address*>(this->val_), I::kNodeIsIndependentShift);
+}
+
+template <class T>
+bool PersistentBase<T>::IsNearDeath() const {
+  typedef internal::Internals I;
+  if (this->IsEmpty()) return false;
+  uint8_t node_state = I::GetNodeState(reinterpret_cast<internal::Address*>(this->val_));
+  return node_state == I::kNodeStateIsNearDeathValue || node_state == I::kNodeStateIsPendingValue;
+}
+
 template <class T>
 Global<T>::Global(Global&& other) : PersistentBase<T>(other.val_) {
   if (other.val_ != nullptr) {
@@ -11555,6 +11669,10 @@ Local<Value> FunctionCallbackInfo<T>::operator[](int i) const {
   return Local<Value>(reinterpret_cast<Value*>(values_ + i));
 }
 
+template<typename T>
+Local<Function> FunctionCallbackInfo<T>::Callee() const {
+  return Local<Function>(reinterpret_cast<Function*>(&implicit_args_[kCalleeIndex]));
+}
 
 template<typename T>
 Local<Object> FunctionCallbackInfo<T>::This() const {
@@ -11748,6 +11866,7 @@ Local<Value> Object::GetInternalField(int index) {
 #ifndef V8_ENABLE_CHECKS
   using A = internal::Address;
   using I = internal::Internals;
+  using O = internal::Object*;
   A obj = *reinterpret_cast<A*>(this);
   // Fast path: If the object is a plain JSObject, which is the common case, we
   // know where to find the internal fields and can return the value directly.
@@ -11756,15 +11875,16 @@ Local<Value> Object::GetInternalField(int index) {
       instance_type == I::kJSApiObjectType ||
       instance_type == I::kJSSpecialApiObjectType) {
     int offset = I::kJSObjectHeaderSize + (I::kEmbedderDataSlotSize * index);
-    A value = I::ReadRawField<A>(obj, offset);
+    O value = I::ReadRawField<O>(obj, offset);
 #ifdef V8_COMPRESS_POINTERS
     // We read the full pointer value and then decompress it in order to avoid
     // dealing with potential endiannes issues.
-    value = I::DecompressTaggedAnyField(obj, static_cast<uint32_t>(value));
+    uint32_t ptr = I::ReadRawField<uint32_t>(obj, offset);
+    value = reinterpret_cast<O>(I::DecompressTaggedAnyField(obj, ptr));
 #endif
     internal::Isolate* isolate =
         internal::IsolateFromNeverReadOnlySpaceObject(obj);
-    A* result = HandleScope::CreateHandle(isolate, value);
+    O* result = HandleScope::CreateHandle(isolate, value);
     return Local<Value>(reinterpret_cast<Value*>(result));
   }
 #endif
@@ -12393,21 +12513,23 @@ Local<Value> Context::GetEmbedderData(int index) {
 #ifndef V8_ENABLE_CHECKS
   using A = internal::Address;
   using I = internal::Internals;
+  using O = internal::Object*;
   A ctx = *reinterpret_cast<const A*>(this);
   A embedder_data =
       I::ReadTaggedPointerField(ctx, I::kNativeContextEmbedderDataOffset);
   int value_offset =
       I::kEmbedderDataArrayHeaderSize + (I::kEmbedderDataSlotSize * index);
-  A value = I::ReadRawField<A>(embedder_data, value_offset);
+  O value = I::ReadRawField<O>(embedder_data, value_offset);
 #ifdef V8_COMPRESS_POINTERS
   // We read the full pointer value and then decompress it in order to avoid
   // dealing with potential endiannes issues.
+  uint32_t ptr = I::ReadRawField<uint32_t>(embedder_data, value_offset);
   value =
-      I::DecompressTaggedAnyField(embedder_data, static_cast<uint32_t>(value));
+      reinterpret_cast<O>(I::DecompressTaggedAnyField(embedder_data, ptr));
 #endif
   internal::Isolate* isolate = internal::IsolateFromNeverReadOnlySpaceObject(
       *reinterpret_cast<A*>(this));
-  A* result = HandleScope::CreateHandle(isolate, value);
+  O* result = HandleScope::CreateHandle(isolate, value);
   return Local<Value>(reinterpret_cast<Value*>(result));
 #else
   return SlowGetEmbedderData(index);
diff --git a/src/api/api.cc b/src/api/api.cc
index a56b7e1a7d..1d2ac91365 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -143,6 +143,141 @@
 
 namespace v8 {
 
+/*
+ * Most API methods should use one of the three macros:
+ *
+ * ENTER_V8, ENTER_V8_NO_SCRIPT, ENTER_V8_NO_SCRIPT_NO_EXCEPTION.
+ *
+ * The latter two assume that no script is executed, and no exceptions are
+ * scheduled in addition (respectively). Creating a pending exception and
+ * removing it before returning is ok.
+ *
+ * Exceptions should be handled either by invoking one of the
+ * RETURN_ON_FAILED_EXECUTION* macros.
+ *
+ * Don't use macros with DO_NOT_USE in their name.
+ *
+ * TODO(jochen): Document debugger specific macros.
+ * TODO(jochen): Document LOG_API and other RuntimeCallStats macros.
+ * TODO(jochen): All API methods should invoke one of the ENTER_V8* macros.
+ * TODO(jochen): Remove calls form API methods to DO_NOT_USE macros.
+ */
+
+#define LOG_API(isolate, class_name, function_name)                           \
+  i::RuntimeCallTimerScope _runtime_timer(                                    \
+      isolate, i::RuntimeCallCounterId::kAPI_##class_name##_##function_name); \
+  LOG(isolate, ApiEntryCall("v8::" #class_name "::" #function_name))
+
+#define ENTER_V8_DO_NOT_USE(isolate) i::VMState<v8::OTHER> __state__((isolate))
+
+#define ENTER_V8_HELPER_DO_NOT_USE(isolate, context, class_name,  \
+                                   function_name, bailout_value,  \
+                                   HandleScopeClass, do_callback) \
+  if (IsExecutionTerminatingCheck(isolate)) {                     \
+    return bailout_value;                                         \
+  }                                                               \
+  HandleScopeClass handle_scope(isolate);                         \
+  CallDepthScope<do_callback> call_depth_scope(isolate, context); \
+  LOG_API(isolate, class_name, function_name);                    \
+  i::VMState<v8::OTHER> __state__((isolate));                     \
+  bool has_pending_exception = false
+
+#define PREPARE_FOR_DEBUG_INTERFACE_EXECUTION_WITH_ISOLATE(isolate, T)       \
+  if (IsExecutionTerminatingCheck(isolate)) {                                \
+    return MaybeLocal<T>();                                                  \
+  }                                                                          \
+  InternalEscapableScope handle_scope(isolate);                              \
+  CallDepthScope<false> call_depth_scope(isolate, v8::Local<v8::Context>()); \
+  i::VMState<v8::OTHER> __state__((isolate));                                \
+  bool has_pending_exception = false
+
+#define PREPARE_FOR_EXECUTION_WITH_CONTEXT(context, class_name, function_name, \
+                                           bailout_value, HandleScopeClass,    \
+                                           do_callback)                        \
+  auto isolate = context.IsEmpty()                                             \
+                     ? i::Isolate::Current()                                   \
+                     : reinterpret_cast<i::Isolate*>(context->GetIsolate());   \
+  ENTER_V8_HELPER_DO_NOT_USE(isolate, context, class_name, function_name,      \
+                             bailout_value, HandleScopeClass, do_callback);
+
+#define PREPARE_FOR_EXECUTION(context, class_name, function_name, T)          \
+  PREPARE_FOR_EXECUTION_WITH_CONTEXT(context, class_name, function_name,      \
+                                     MaybeLocal<T>(), InternalEscapableScope, \
+                                     false)
+
+#define ENTER_V8(isolate, context, class_name, function_name, bailout_value, \
+                 HandleScopeClass)                                           \
+  ENTER_V8_HELPER_DO_NOT_USE(isolate, context, class_name, function_name,    \
+                             bailout_value, HandleScopeClass, true)
+
+#ifdef DEBUG
+#define ENTER_V8_NO_SCRIPT(isolate, context, class_name, function_name,   \
+                           bailout_value, HandleScopeClass)               \
+  ENTER_V8_HELPER_DO_NOT_USE(isolate, context, class_name, function_name, \
+                             bailout_value, HandleScopeClass, false);     \
+  i::DisallowJavascriptExecutionDebugOnly __no_script__((isolate))
+
+#define ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate)                    \
+  i::VMState<v8::OTHER> __state__((isolate));                       \
+  i::DisallowJavascriptExecutionDebugOnly __no_script__((isolate)); \
+  i::DisallowExceptions __no_exceptions__((isolate))
+
+#define ENTER_V8_FOR_NEW_CONTEXT(isolate)     \
+  i::VMState<v8::OTHER> __state__((isolate)); \
+  i::DisallowExceptions __no_exceptions__((isolate))
+#else
+#define ENTER_V8_NO_SCRIPT(isolate, context, class_name, function_name,   \
+                           bailout_value, HandleScopeClass)               \
+  ENTER_V8_HELPER_DO_NOT_USE(isolate, context, class_name, function_name, \
+                             bailout_value, HandleScopeClass, false)
+
+#define ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate) \
+  i::VMState<v8::OTHER> __state__((isolate));
+
+#define ENTER_V8_FOR_NEW_CONTEXT(isolate) \
+  i::VMState<v8::OTHER> __state__((isolate));
+#endif  // DEBUG
+
+#define EXCEPTION_BAILOUT_CHECK_SCOPED_DO_NOT_USE(isolate, value) \
+  do {                                                            \
+    if (has_pending_exception) {                                  \
+      call_depth_scope.Escape();                                  \
+      return value;                                               \
+    }                                                             \
+  } while (false)
+
+#define RETURN_ON_FAILED_EXECUTION(T) \
+  EXCEPTION_BAILOUT_CHECK_SCOPED_DO_NOT_USE(isolate, MaybeLocal<T>())
+
+#define RETURN_ON_FAILED_EXECUTION_PRIMITIVE(T) \
+  EXCEPTION_BAILOUT_CHECK_SCOPED_DO_NOT_USE(isolate, Nothing<T>())
+
+#define RETURN_ESCAPED(value) return handle_scope.Escape(value);
+
+namespace {
+
+Local<Context> UnsafeContextFromHeapObject(i::Handle<i::Object> obj) {
+  i::MemoryChunk* chunk = i::MemoryChunk::FromHeapObject(i::HeapObject::cast(*obj));
+  return reinterpret_cast<Isolate*>(chunk->heap()->isolate())->GetCurrentContext();
+}
+
+Local<Context> ContextFromNeverReadOnlySpaceObject(i::Handle<i::JSReceiver> obj) {
+  return reinterpret_cast<v8::Isolate*>(obj->GetIsolate())->GetCurrentContext();
+}
+
+// TODO(jochen): This should be #ifdef DEBUG
+#ifdef V8_CHECK_MICROTASKS_SCOPES_CONSISTENCY
+void CheckMicrotasksScopesConsistency(i::MicrotaskQueue* microtask_queue) {
+  if (microtask_queue &&
+      microtask_queue->microtasks_policy() == v8::MicrotasksPolicy::kScoped) {
+    DCHECK(microtask_queue->GetMicrotasksScopeDepth() ||
+           !microtask_queue->DebugMicrotasksScopeDepthIsZero());
+  }
+}
+#endif
+
+}  // namespace
+
 static ScriptOrigin GetScriptOriginForScript(i::Isolate* isolate,
                                              i::Handle<i::Script> script) {
   i::Handle<i::Object> scriptName(script->GetNameOrSourceURL(), isolate);
@@ -727,6 +862,26 @@ void ResourceConstraints::ConfigureDefaults(uint64_t physical_memory,
   }
 }
 
+i::Object** V8::GlobalizeReference(i::Isolate* isolate, i::Object** obj) {
+  return reinterpret_cast<i::Object**>(GlobalizeReference(isolate, reinterpret_cast<i::Address*>(obj)));
+}
+
+void V8::MakeWeak(i::Object** location, void* parameter, WeakCallbackInfo<void>::Callback weak_callback, WeakCallbackType type) {
+  MakeWeak(reinterpret_cast<i::Address*>(location), parameter, weak_callback, type);
+}
+
+void V8::MakeWeak(i::Object*** location_addr) {
+  MakeWeak(reinterpret_cast<i::Address**>(location_addr));
+}
+
+void* V8::ClearWeak(i::Object** location) {
+  return i::GlobalHandles::ClearWeakness(reinterpret_cast<i::Address*>(location));
+}
+
+void V8::DisposeGlobal(i::Object** location) {
+  DisposeGlobal(reinterpret_cast<i::Address*>(location));
+}
+
 i::Address* V8::GlobalizeReference(i::Isolate* isolate, i::Address* obj) {
   LOG_API(isolate, Persistent, New);
   i::Handle<i::Object> result = isolate->global_handles()->Create(*obj);
@@ -869,6 +1024,9 @@ int HandleScope::NumberOfHandles(Isolate* isolate) {
       reinterpret_cast<i::Isolate*>(isolate));
 }
 
+i::Object** HandleScope::CreateHandle(i::Isolate* isolate, i::Object* value) {
+  return reinterpret_cast<i::Object**>(CreateHandle(isolate, reinterpret_cast<i::Address>(value)));
+}
 i::Address* HandleScope::CreateHandle(i::Isolate* isolate, i::Address value) {
   return i::HandleScope::CreateHandle(isolate, value);
 }
@@ -880,6 +1038,9 @@ EscapableHandleScope::EscapableHandleScope(Isolate* v8_isolate) {
   Initialize(v8_isolate);
 }
 
+i::Object** EscapableHandleScope::Escape(i::Object** escape_value) {
+  return reinterpret_cast<i::Object**>(Escape(reinterpret_cast<i::Address*>(escape_value)));
+}
 i::Address* EscapableHandleScope::Escape(i::Address* escape_value) {
   i::Heap* heap = reinterpret_cast<i::Isolate*>(GetIsolate())->heap();
   Utils::ApiCheck(i::Object(*escape_slot_).IsTheHole(heap->isolate()),
@@ -1227,6 +1388,11 @@ static Local<FunctionTemplate> FunctionTemplateNew(
   return Utils::ToLocal(obj);
 }
 
+Local<FunctionTemplate> FunctionTemplate::New(
+    Isolate* isolate, FunctionCallback callback, v8::Local<Value> data,
+    v8::Local<Signature> signature, int length, ConstructorBehavior behavior) {
+  return FunctionTemplate::New(isolate, callback, data, signature, length, behavior, SideEffectType::kHasSideEffect);
+}
 Local<FunctionTemplate> FunctionTemplate::New(
     Isolate* isolate, FunctionCallback callback, v8::Local<Value> data,
     v8::Local<Signature> signature, int length, ConstructorBehavior behavior,
@@ -1539,6 +1705,16 @@ void ObjectTemplate::SetAccessor(v8::Local<String> name,
                       getter_side_effect_type, setter_side_effect_type);
 }
 
+void ObjectTemplate::SetAccessor(v8::Local<Name> name,
+                                 AccessorNameGetterCallback getter,
+                                 AccessorNameSetterCallback setter,
+                                 v8::Local<Value> data, AccessControl settings,
+                                 PropertyAttribute attribute,
+                                 v8::Local<AccessorSignature> signature) {
+  ObjectTemplate::SetAccessor(name, getter, setter, data, settings, attribute,
+                              signature, SideEffectType::kHasSideEffect,
+                              SideEffectType::kHasSideEffect);
+}
 void ObjectTemplate::SetAccessor(v8::Local<Name> name,
                                  AccessorNameGetterCallback getter,
                                  AccessorNameSetterCallback setter,
@@ -1632,6 +1808,13 @@ static void ObjectTemplateSetNamedPropertyHandler(
   i::FunctionTemplateInfo::SetNamedPropertyHandler(isolate, cons, obj);
 }
 
+void ObjectTemplate::SetNamedPropertyHandler(
+    NamedPropertyGetterCallback getter, NamedPropertySetterCallback setter,
+    NamedPropertyQueryCallback query, NamedPropertyDeleterCallback remover,
+    NamedPropertyEnumeratorCallback enumerator, Local<Value> data) {
+  ObjectTemplateSetNamedPropertyHandler(this, getter, setter, query, nullptr, remover, enumerator, nullptr, data, PropertyHandlerFlags::kOnlyInterceptStrings);
+}
+
 void ObjectTemplate::SetHandler(
     const NamedPropertyHandlerConfiguration& config) {
   ObjectTemplateSetNamedPropertyHandler(
@@ -1918,6 +2101,26 @@ MaybeLocal<Value> Script::Run(Local<Context> context) {
   RETURN_ESCAPED(result);
 }
 
+Local<Value> Script::Run() {
+  auto self = Utils::OpenHandle(this, true);
+  if (self.is_null()) return Local<Value>();
+  auto context = UnsafeContextFromHeapObject(self);
+  return Run(context).FromMaybe(Local<Value>());
+}
+
+Local<Script> Script::Compile(v8::Local<String> source, v8::ScriptOrigin* origin) {
+  auto str = Utils::OpenHandle(*source);
+  auto context = UnsafeContextFromHeapObject(str);
+  return Compile(context, source, origin).FromMaybe(Local<Script>());
+}
+
+Local<Script> Script::Compile(v8::Local<String> source, v8::Local<String> file_name) {
+  auto str = Utils::OpenHandle(*source);
+  auto context = UnsafeContextFromHeapObject(str);
+  ScriptOrigin origin(context->GetIsolate(), file_name);
+  return Compile(context, source, &origin).FromMaybe(Local<Script>());
+}
+
 Local<Value> ScriptOrModule::GetResourceName() {
   i::Handle<i::Script> obj = Utils::OpenHandle(this);
   i::Isolate* isolate = obj->GetIsolate();
@@ -2607,7 +2810,18 @@ MaybeLocal<Script> Script::Compile(Local<Context> context, Local<String> source,
 }
 
 // --- E x c e p t i o n s ---
-
+v8::TryCatch::TryCatch()
+    : isolate_(i::Isolate::Current()),
+      next_(isolate_->try_catch_handler()),
+      is_verbose_(false),
+      can_continue_(true),
+      capture_message_(true),
+      rethrow_(false),
+      has_terminated_(false) {
+  ResetInternal();
+  js_stack_comparable_address_ = reinterpret_cast<void*>(i::SimulatorStack::RegisterJSStackComparableAddress(isolate_));
+  isolate_->RegisterTryCatchHandler(this);
+}
 v8::TryCatch::TryCatch(v8::Isolate* isolate)
     : isolate_(reinterpret_cast<i::Isolate*>(isolate)),
       next_(isolate_->try_catch_handler()),
@@ -2705,6 +2919,11 @@ MaybeLocal<Value> v8::TryCatch::StackTrace(Local<Context> context) const {
   return StackTrace(context, Exception());
 }
 
+v8::Local<Value> v8::TryCatch::StackTrace() const {
+  auto context = reinterpret_cast<v8::Isolate*>(isolate_)->GetCurrentContext();
+  return StackTrace(context).FromMaybe(v8::Local<Value>());
+}
+
 v8::Local<v8::Message> v8::TryCatch::Message() const {
   i::Object message(reinterpret_cast<i::Address>(message_obj_));
   DCHECK(message.IsJSMessageObject() || message.IsTheHole(isolate_));
@@ -2788,6 +3007,16 @@ Maybe<int> Message::GetLineNumber(Local<Context> context) const {
   return Just(self->GetLineNumber());
 }
 
+int Message::GetLineNumber() const {
+  auto context = UnsafeContextFromHeapObject(Utils::OpenHandle(this));
+  return GetLineNumber(context).FromMaybe(0);
+}
+
+Local<String> Message::GetSourceLine() const {
+  auto context = UnsafeContextFromHeapObject(Utils::OpenHandle(this));
+  return GetSourceLine(context).FromMaybe(Local<String>());
+}
+
 int Message::GetStartPosition() const {
   auto self = Utils::OpenHandle(this);
   i::Isolate* isolate = self->GetIsolate();
@@ -3435,6 +3664,10 @@ MaybeLocal<String> Value::ToString(Local<Context> context) const {
   RETURN_ESCAPED(result);
 }
 
+Local<String> Value::ToString(Isolate* isolate) const {
+  return ToString(isolate->GetCurrentContext()).FromMaybe(Local<String>());
+}
+
 MaybeLocal<String> Value::ToDetailString(Local<Context> context) const {
   i::Handle<i::Object> obj = Utils::OpenHandle(this);
   if (obj->IsString()) return ToApiHandle<String>(obj);
@@ -3456,6 +3689,10 @@ MaybeLocal<Object> Value::ToObject(Local<Context> context) const {
   RETURN_ESCAPED(result);
 }
 
+Local<Object> Value::ToObject(Isolate* isolate) const {
+  return ToObject(isolate->GetCurrentContext()).FromMaybe(Local<Object>());
+}
+
 MaybeLocal<BigInt> Value::ToBigInt(Local<Context> context) const {
   i::Handle<i::Object> obj = Utils::OpenHandle(this);
   if (obj->IsBigInt()) return ToApiHandle<BigInt>(obj);
@@ -3467,11 +3704,20 @@ MaybeLocal<BigInt> Value::ToBigInt(Local<Context> context) const {
   RETURN_ESCAPED(result);
 }
 
+Maybe<bool> Value::BooleanValue(Local<Context> context) const {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());
+  return Just(Utils::OpenHandle(this)->BooleanValue(isolate));
+}
+
 bool Value::BooleanValue(Isolate* v8_isolate) const {
   return Utils::OpenHandle(this)->BooleanValue(
       reinterpret_cast<i::Isolate*>(v8_isolate));
 }
 
+MaybeLocal<Boolean> Value::ToBoolean(Local<Context> context) const {
+  return ToBoolean(context->GetIsolate());
+}
+
 Local<Boolean> Value::ToBoolean(Isolate* v8_isolate) const {
   auto isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
   ASSERT_NO_SCRIPT_NO_EXCEPTION(isolate);
@@ -3490,6 +3736,10 @@ MaybeLocal<Number> Value::ToNumber(Local<Context> context) const {
   RETURN_ESCAPED(result);
 }
 
+Local<Number> Value::ToNumber(Isolate* isolate) const {
+  return ToNumber(isolate->GetCurrentContext()).FromMaybe(Local<Number>());
+}
+
 MaybeLocal<Integer> Value::ToInteger(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsSmi()) return ToApiHandle<Integer>(obj);
@@ -3501,6 +3751,10 @@ MaybeLocal<Integer> Value::ToInteger(Local<Context> context) const {
   RETURN_ESCAPED(result);
 }
 
+Local<Integer> Value::ToInteger(Isolate* isolate) const {
+  return ToInteger(isolate->GetCurrentContext()).FromMaybe(Local<Integer>());
+}
+
 MaybeLocal<Int32> Value::ToInt32(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsSmi()) return ToApiHandle<Int32>(obj);
@@ -3512,6 +3766,10 @@ MaybeLocal<Int32> Value::ToInt32(Local<Context> context) const {
   RETURN_ESCAPED(result);
 }
 
+Local<Int32> Value::ToInt32(Isolate* isolate) const {
+  return ToInt32(isolate->GetCurrentContext()).FromMaybe(Local<Int32>());
+}
+
 MaybeLocal<Uint32> Value::ToUint32(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsSmi()) return ToApiHandle<Uint32>(obj);
@@ -3964,6 +4222,61 @@ Maybe<bool> v8::Object::Set(v8::Local<v8::Context> context,
   return Just(true);
 }
 
+bool v8::Object::Set(Local<Value> key, Local<Value> value) {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return Set(context, key, value).FromMaybe(false);
+}
+
+bool v8::Object::Set(uint32_t index, Local<Value> value) {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return Set(context, index, value).FromMaybe(false);
+}
+
+Local<Value> v8::Object::Get(Local<Value> key) {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return Get(context, key).FromMaybe(Local<Value>());
+}
+
+Local<Value> v8::Object::Get(uint32_t index) {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return Get(context, index).FromMaybe(Local<Value>());
+}
+
+Local<Array> v8::Object::GetPropertyNames() {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return GetPropertyNames(context).FromMaybe(Local<Array>());
+}
+
+Local<Array> v8::Object::GetOwnPropertyNames() {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return GetOwnPropertyNames(context).FromMaybe(Local<Array>());
+}
+
+Local<Value> v8::Object::GetRealNamedProperty(Local<String> key) {
+  auto context = UnsafeContextFromHeapObject(Utils::OpenHandle(this));
+  return GetRealNamedProperty(context, key).FromMaybe(Local<Value>());
+}
+
+bool v8::Object::Has(Local<Value> key) {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return Has(context, key).FromMaybe(false);
+}
+
+bool v8::Object::HasOwnProperty(Local<String> key) {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return HasOwnProperty(context, key).FromMaybe(false);
+}
+
+bool v8::Object::HasRealNamedProperty(Local<String> key) {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return HasRealNamedProperty(context, key).FromMaybe(false);
+}
+
+bool v8::Object::HasRealNamedCallbackProperty(Local<String> key) {
+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));
+  return HasRealNamedCallbackProperty(context, key).FromMaybe(false);
+}
+
 Maybe<bool> v8::Object::Set(v8::Local<v8::Context> context, uint32_t index,
                             v8::Local<Value> value) {
   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());
@@ -4497,6 +4810,29 @@ Maybe<bool> Object::SetAccessor(Local<Context> context, Local<Name> name,
                            getter_side_effect_type, setter_side_effect_type);
 }
 
+bool Object::SetAccessor(Local<Name> name,
+                         AccessorNameGetterCallback getter,
+                         AccessorNameSetterCallback setter,
+                         v8::Local<Value> data,
+                         AccessControl settings,
+                         PropertyAttribute attribute) {
+  auto context = UnsafeContextFromHeapObject(Utils::OpenHandle(this));
+  return ObjectSetAccessor(
+      context,
+      this,
+      name,
+      getter,
+      setter,
+      data,
+      settings,
+      attribute,
+      i::FLAG_disable_old_api_accessors,
+      false,
+      SideEffectType::kHasSideEffect,
+      SideEffectType::kHasSideEffect
+    ).FromMaybe(false);
+}
+
 void Object::SetAccessorProperty(Local<Name> name, Local<Function> getter,
                                  Local<Function> setter,
                                  PropertyAttribute attribute,
@@ -4826,6 +5162,12 @@ MaybeLocal<Object> Function::NewInstance(Local<Context> context, int argc,
                                        SideEffectType::kHasSideEffect);
 }
 
+Local<v8::Object> Function::NewInstance(int argc,
+                                        v8::Local<v8::Value> argv[]) const {
+  auto context = UnsafeContextFromHeapObject(Utils::OpenHandle(this));
+  return NewInstance(context, argc, argv).FromMaybe(Local<v8::Object>());
+}
+
 MaybeLocal<Object> Function::NewInstanceWithSideEffectType(
     Local<Context> context, int argc, v8::Local<v8::Value> argv[],
     SideEffectType side_effect_type) const {
@@ -5454,21 +5796,21 @@ String::ExternalStringResource* String::GetExternalStringResourceSlow() const {
 }
 
 void String::ExternalStringResource::UpdateDataCache() {
-  DCHECK(IsCacheable());
+  DCHECK(!IsCompressible());
   cached_data_ = data();
 }
 
 void String::ExternalStringResource::CheckCachedDataInvariants() const {
-  DCHECK(IsCacheable() && cached_data_ != nullptr);
+  DCHECK(!IsCompressible() && cached_data_ != nullptr);
 }
 
 void String::ExternalOneByteStringResource::UpdateDataCache() {
-  DCHECK(IsCacheable());
+  DCHECK(!IsCompressible());
   cached_data_ = data();
 }
 
 void String::ExternalOneByteStringResource::CheckCachedDataInvariants() const {
-  DCHECK(IsCacheable() && cached_data_ != nullptr);
+  DCHECK(!IsCompressible() && cached_data_ != nullptr);
 }
 
 String::ExternalStringResourceBase* String::GetExternalStringResourceBaseSlow(
@@ -6233,6 +6575,13 @@ MaybeLocal<v8::Function> FunctionTemplate::GetFunction(Local<Context> context) {
   RETURN_ESCAPED(result);
 }
 
+Local<v8::Function> FunctionTemplate::GetFunction() {
+  Local<Context> context =
+      reinterpret_cast<v8::Isolate*>(Utils::OpenHandle(this)->GetIsolate())
+          ->GetCurrentContext();
+  return GetFunction(context).FromMaybe(Local<v8::Function>());
+}
+
 MaybeLocal<v8::Object> FunctionTemplate::NewRemoteInstance() {
   auto self = Utils::OpenHandle(this);
   i::Isolate* isolate = self->GetIsolate();
@@ -6314,9 +6663,9 @@ inline int StringLength(const uint16_t* string) {
 
 V8_WARN_UNUSED_RESULT
 inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
-                                           NewStringType type,
+                                           v8::NewStringType type,
                                            i::Vector<const char> string) {
-  if (type == NewStringType::kInternalized) {
+  if (type == v8::NewStringType::kInternalized) {
     return factory->InternalizeUtf8String(string);
   }
   return factory->NewStringFromUtf8(string);
@@ -6324,9 +6673,9 @@ inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
 
 V8_WARN_UNUSED_RESULT
 inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
-                                           NewStringType type,
+                                           v8::NewStringType type,
                                            i::Vector<const uint8_t> string) {
-  if (type == NewStringType::kInternalized) {
+  if (type == v8::NewStringType::kInternalized) {
     return factory->InternalizeString(string);
   }
   return factory->NewStringFromOneByte(string);
@@ -6334,9 +6683,9 @@ inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
 
 V8_WARN_UNUSED_RESULT
 inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
-                                           NewStringType type,
+                                           v8::NewStringType type,
                                            i::Vector<const uint16_t> string) {
-  if (type == NewStringType::kInternalized) {
+  if (type == v8::NewStringType::kInternalized) {
     return factory->InternalizeString(string);
   }
   return factory->NewStringFromTwoByte(string);
@@ -6367,7 +6716,7 @@ STATIC_ASSERT(v8::String::kMaxLength == i::String::kMaxLength);
   }
 
 Local<String> String::NewFromUtf8Literal(Isolate* isolate, const char* literal,
-                                         NewStringType type, int length) {
+                                         v8::NewStringType type, int length) {
   DCHECK_LE(length, i::String::kMaxLength);
   i::Isolate* i_isolate = reinterpret_cast<internal::Isolate*>(isolate);
   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
@@ -6379,21 +6728,39 @@ Local<String> String::NewFromUtf8Literal(Isolate* isolate, const char* literal,
   return Utils::ToLocal(handle_result);
 }
 
+Local<String> String::NewFromUtf8(Isolate* isolate,
+                                  const char* data,
+                                  NewStringType type,
+                                  int length) {
+  NEW_STRING(isolate, String, NewFromUtf8, char, data,
+             static_cast<v8::NewStringType>(type), length);
+  return result.FromMaybe(Local<String>());
+}
+
+Local<String> String::NewFromTwoByte(Isolate* isolate,
+                                     const uint16_t* data,
+                                     NewStringType type,
+                                     int length) {
+  NEW_STRING(isolate, String, NewFromTwoByte, uint16_t, data,
+             static_cast<v8::NewStringType>(type), length);
+  return result.FromMaybe(Local<String>());
+}
+
 MaybeLocal<String> String::NewFromUtf8(Isolate* isolate, const char* data,
-                                       NewStringType type, int length) {
+                                       v8::NewStringType type, int length) {
   NEW_STRING(isolate, String, NewFromUtf8, char, data, type, length);
   return result;
 }
 
 MaybeLocal<String> String::NewFromOneByte(Isolate* isolate, const uint8_t* data,
-                                          NewStringType type, int length) {
+                                          v8::NewStringType type, int length) {
   NEW_STRING(isolate, String, NewFromOneByte, uint8_t, data, type, length);
   return result;
 }
 
 MaybeLocal<String> String::NewFromTwoByte(Isolate* isolate,
                                           const uint16_t* data,
-                                          NewStringType type, int length) {
+                                          v8::NewStringType type, int length) {
   NEW_STRING(isolate, String, NewFromTwoByte, uint16_t, data, type, length);
   return result;
 }
@@ -6763,6 +7130,11 @@ MaybeLocal<v8::Value> v8::Date::New(Local<Context> context, double time) {
   RETURN_ESCAPED(result);
 }
 
+Local<v8::Value> v8::Date::New(Isolate* isolate, double time) {
+  auto context = isolate->GetCurrentContext();
+  return New(context, time).FromMaybe(Local<v8::Value>());
+}
+
 double v8::Date::ValueOf() const {
   i::Handle<i::Object> obj = Utils::OpenHandle(this);
   i::Handle<i::JSDate> jsdate = i::Handle<i::JSDate>::cast(obj);
@@ -9294,6 +9666,9 @@ String::Utf8Value::Utf8Value(v8::Isolate* isolate, v8::Local<v8::Value> obj)
   str->WriteUtf8(isolate, str_);
 }
 
+String::Utf8Value::Utf8Value(v8::Local<v8::Value> obj)
+    : String::Utf8Value::Utf8Value(Isolate::GetCurrent(), obj) {}
+
 String::Utf8Value::~Utf8Value() { i::DeleteArray(str_); }
 
 String::Value::Value(v8::Isolate* isolate, v8::Local<v8::Value> obj)
@@ -9311,6 +9686,9 @@ String::Value::Value(v8::Isolate* isolate, v8::Local<v8::Value> obj)
   str->Write(isolate, str_);
 }
 
+String::Value::Value(v8::Local<v8::Value> obj)
+    : String::Value::Value(v8::Isolate::GetCurrent(), obj) {}
+
 String::Value::~Value() { i::DeleteArray(str_); }
 
 #define DEFINE_ERROR(NAME, name)                                         \
diff --git a/src/debug/debug-wasm-objects.cc b/src/debug/debug-wasm-objects.cc
index c3560a4d15..20522f65a8 100644
--- a/src/debug/debug-wasm-objects.cc
+++ b/src/debug/debug-wasm-objects.cc
@@ -140,7 +140,7 @@ struct IndexedDebugProxy {
   static v8::Local<v8::FunctionTemplate> CreateTemplate(v8::Isolate* isolate) {
     Local<v8::FunctionTemplate> templ = v8::FunctionTemplate::New(isolate);
     templ->SetClassName(
-        v8::String::NewFromUtf8(isolate, T::kClassName).ToLocalChecked());
+        v8::String::NewFromUtf8(isolate, T::kClassName, v8::NewStringType::kNormal).ToLocalChecked());
     templ->InstanceTemplate()->SetInternalFieldCount(T::kFieldCount);
     templ->InstanceTemplate()->SetHandler(
         v8::IndexedPropertyHandlerConfiguration(
diff --git a/src/execution/isolate-data.h b/src/execution/isolate-data.h
index a6610c12f0..a56efad6c0 100644
--- a/src/execution/isolate-data.h
+++ b/src/execution/isolate-data.h
@@ -139,6 +139,7 @@ class IsolateData final {
   // beginning of IsolateData.
 #define FIELDS(V)                                                             \
   V(kEmbedderDataOffset, Internals::kNumIsolateDataSlots* kSystemPointerSize) \
+  V(kCompatibilityPaddingOffset, kInt64Size* 3)                               \
   V(kFastCCallCallerFPOffset, kSystemPointerSize)                             \
   V(kFastCCallCallerPCOffset, kSystemPointerSize)                             \
   V(kFastApiCallTargetOffset, kSystemPointerSize)                             \
@@ -172,6 +173,8 @@ class IsolateData final {
   // runtime checks.
   void* embedder_data_[Internals::kNumIsolateDataSlots] = {};
 
+  int64_t compatibility_padding_[3];
+
   // Stores the state of the caller for TurboAssembler::CallCFunction so that
   // the sampling CPU profiler can iterate the stack during such calls. These
   // are stored on IsolateData so that they can be stored to with only one move
diff --git a/src/extensions/gc-extension.cc b/src/extensions/gc-extension.cc
index 6f1c601d8d..4e7928c027 100644
--- a/src/extensions/gc-extension.cc
+++ b/src/extensions/gc-extension.cc
@@ -25,13 +25,13 @@ struct GCOptions {
 Maybe<bool> IsProperty(v8::Isolate* isolate, v8::Local<v8::Context> ctx,
                        v8::Local<v8::Object> object, const char* key,
                        const char* value) {
-  auto k = v8::String::NewFromUtf8(isolate, key).ToLocalChecked();
+  auto k = v8::String::NewFromUtf8(isolate, key, v8::NewStringType::kNormal).ToLocalChecked();
   // Get will return undefined for non-existing keys which will make
   // StrictEquals fail.
   auto maybe_property = object->Get(ctx, k);
   if (maybe_property.IsEmpty()) return Nothing<bool>();
   return Just<bool>(maybe_property.ToLocalChecked()->StrictEquals(
-      v8::String::NewFromUtf8(isolate, value).ToLocalChecked()));
+      v8::String::NewFromUtf8(isolate, value, v8::NewStringType::kNormal).ToLocalChecked()));
 }
 
 Maybe<GCOptions> Parse(v8::Isolate* isolate,
diff --git a/src/extensions/statistics-extension.cc b/src/extensions/statistics-extension.cc
index 9d63d760ec..144ffc3dc5 100644
--- a/src/extensions/statistics-extension.cc
+++ b/src/extensions/statistics-extension.cc
@@ -29,7 +29,7 @@ static void AddCounter(v8::Isolate* isolate,
   if (counter->Enabled()) {
     object
         ->Set(isolate->GetCurrentContext(),
-              v8::String::NewFromUtf8(isolate, name).ToLocalChecked(),
+              v8::String::NewFromUtf8(isolate, name, v8::NewStringType::kNormal).ToLocalChecked(),
               v8::Number::New(isolate, *counter->GetInternalPointer()))
         .FromJust();
   }
@@ -39,7 +39,7 @@ static void AddNumber(v8::Isolate* isolate, v8::Local<v8::Object> object,
                       double value, const char* name) {
   object
       ->Set(isolate->GetCurrentContext(),
-            v8::String::NewFromUtf8(isolate, name).ToLocalChecked(),
+            v8::String::NewFromUtf8(isolate, name, v8::NewStringType::kNormal).ToLocalChecked(),
             v8::Number::New(isolate, value))
       .FromJust();
 }
@@ -51,7 +51,7 @@ static void AddNumber64(v8::Isolate* isolate,
                         const char* name) {
   object
       ->Set(isolate->GetCurrentContext(),
-            v8::String::NewFromUtf8(isolate, name).ToLocalChecked(),
+            v8::String::NewFromUtf8(isolate, name, v8::NewStringType::kNormal).ToLocalChecked(),
             v8::Number::New(isolate, static_cast<double>(value)))
       .FromJust();
 }
diff --git a/src/extensions/vtunedomain-support-extension.cc b/src/extensions/vtunedomain-support-extension.cc
index 793ffec716..aafb48d5f6 100644
--- a/src/extensions/vtunedomain-support-extension.cc
+++ b/src/extensions/vtunedomain-support-extension.cc
@@ -131,7 +131,7 @@ void VTuneDomainSupportExtension::Mark(
   int r = 0;
   if ((r = libvtune::invoke(params.str().c_str())) != 0) {
     args.GetIsolate()->ThrowException(
-        v8::String::NewFromUtf8(args.GetIsolate(), std::to_string(r).c_str())
+        v8::String::NewFromUtf8(args.GetIsolate(), std::to_string(r).c_str(), v8::NewStringType::kNormal)
             .ToLocalChecked());
   }
 }
diff --git a/src/flags/flag-definitions.h b/src/flags/flag-definitions.h
index 1aa25fa832..0263166ea5 100644
--- a/src/flags/flag-definitions.h
+++ b/src/flags/flag-definitions.h
@@ -244,7 +244,7 @@ DEFINE_BOOL(allow_overwriting_for_next_flag, false,
 // Flags for language modes and experimental language features.
 DEFINE_BOOL(use_strict, false, "enforce strict mode")
 
-DEFINE_BOOL(harmony, false, "enable all completed harmony features")
+DEFINE_BOOL(harmony, true, "enable all completed harmony features")
 DEFINE_BOOL(harmony_shipping, true, "enable all shipped harmony features")
 // Enabling FinalizationRegistry#cleanupSome also enables weak refs
 DEFINE_IMPLICATION(harmony_weak_refs_with_cleanup_some, harmony_weak_refs)
@@ -1616,7 +1616,7 @@ DEFINE_NEG_NEG_IMPLICATION(text_is_readable, partial_constant_pool)
 #ifdef ENABLE_MINOR_MC
 DEFINE_BOOL(trace_minor_mc_parallel_marking, false,
             "trace parallel marking for the young generation")
-DEFINE_BOOL(minor_mc, false, "perform young generation mark compact GCs")
+DEFINE_BOOL(minor_mc, true, "perform young generation mark compact GCs")
 #else
 DEFINE_BOOL_READONLY(minor_mc, false,
                      "perform young generation mark compact GCs")
diff --git a/src/handles/handles.h b/src/handles/handles.h
index 6bf60affca..14267db351 100644
--- a/src/handles/handles.h
+++ b/src/handles/handles.h
@@ -224,6 +224,7 @@ class V8_NODISCARD HandleScope {
 
   // Creates a new handle with the given value.
   V8_INLINE static Address* CreateHandle(Isolate* isolate, Address value);
+  V8_INLINE static Object** CreateHandle(Isolate* isolate, Object* value);
 
   // Deallocates any extensions used by the current scope.
   V8_EXPORT_PRIVATE static void DeleteExtensions(Isolate* isolate);
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index 4d12c9e9da..1c03eb40e8 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -961,7 +961,7 @@ MaybeHandle<String> Factory::NewExternalStringFromOneByte(
   }
   if (length == 0) return empty_string();
 
-  Handle<Map> map = resource->IsCacheable()
+  Handle<Map> map = !resource->IsCompressible()
                         ? external_one_byte_string_map()
                         : uncached_external_one_byte_string_map();
   Handle<ExternalOneByteString> external_string(
@@ -983,7 +983,7 @@ MaybeHandle<String> Factory::NewExternalStringFromTwoByte(
   }
   if (length == 0) return empty_string();
 
-  Handle<Map> map = resource->IsCacheable() ? external_string_map()
+  Handle<Map> map = !resource->IsCompressible() ? external_string_map()
                                             : uncached_external_string_map();
   Handle<ExternalTwoByteString> external_string(
       ExternalTwoByteString::cast(New(map, AllocationType::kOld)), isolate());
diff --git a/src/interpreter/interpreter.cc b/src/interpreter/interpreter.cc
index a24bbca706..dd5832eda7 100644
--- a/src/interpreter/interpreter.cc
+++ b/src/interpreter/interpreter.cc
@@ -410,7 +410,7 @@ Local<v8::Object> Interpreter::GetDispatchCountersObject() {
       if (counter > 0) {
         std::string to_name = Bytecodes::ToString(to_bytecode);
         Local<v8::String> to_name_object =
-            v8::String::NewFromUtf8(isolate, to_name.c_str()).ToLocalChecked();
+            v8::String::NewFromUtf8(isolate, to_name.c_str(), v8::NewStringType::kNormal).ToLocalChecked();
         Local<v8::Number> counter_object = v8::Number::New(isolate, counter);
         CHECK(counters_row
                   ->DefineOwnProperty(context, to_name_object, counter_object)
@@ -420,7 +420,7 @@ Local<v8::Object> Interpreter::GetDispatchCountersObject() {
 
     std::string from_name = Bytecodes::ToString(from_bytecode);
     Local<v8::String> from_name_object =
-        v8::String::NewFromUtf8(isolate, from_name.c_str()).ToLocalChecked();
+        v8::String::NewFromUtf8(isolate, from_name.c_str(), v8::NewStringType::kNormal).ToLocalChecked();
 
     CHECK(
         counters_map->DefineOwnProperty(context, from_name_object, counters_row)
diff --git a/src/libplatform/default-platform.cc b/src/libplatform/default-platform.cc
index 66057e1a39..454026b12f 100644
--- a/src/libplatform/default-platform.cc
+++ b/src/libplatform/default-platform.cc
@@ -67,6 +67,16 @@ std::unique_ptr<v8::Platform> NewSingleThreadedDefaultPlatform(
   return platform;
 }
 
+v8::Platform* CreateDefaultPlatform(
+    int thread_pool_size, IdleTaskSupport idle_task_support,
+    InProcessStackDumping in_process_stack_dumping,
+    v8::TracingController* tracing_controller) {
+  return NewDefaultPlatform(
+             thread_pool_size, idle_task_support, in_process_stack_dumping,
+             std::unique_ptr<v8::TracingController>(tracing_controller))
+      .release();
+}
+
 V8_PLATFORM_EXPORT std::unique_ptr<JobHandle> NewDefaultJobHandle(
     Platform* platform, TaskPriority priority,
     std::unique_ptr<JobTask> job_task, size_t num_worker_threads) {
diff --git a/src/objects/string-inl.h b/src/objects/string-inl.h
index 5be0141ab8..87f7a4734a 100644
--- a/src/objects/string-inl.h
+++ b/src/objects/string-inl.h
@@ -875,7 +875,7 @@ DEF_GETTER(ExternalOneByteString, mutable_resource,
 void ExternalOneByteString::update_data_cache(Isolate* isolate) {
   DisallowGarbageCollection no_gc;
   if (is_uncached()) {
-    if (resource()->IsCacheable()) mutable_resource()->UpdateDataCache();
+    if (!resource()->IsCompressible()) mutable_resource()->UpdateDataCache();
   } else {
     WriteExternalPointerField(kResourceDataOffset, isolate,
                               reinterpret_cast<Address>(resource()->data()),
@@ -903,7 +903,7 @@ void ExternalOneByteString::set_resource(
 const uint8_t* ExternalOneByteString::GetChars() {
   DisallowGarbageCollection no_gc;
   if (is_uncached()) {
-    if (resource()->IsCacheable()) {
+    if (!resource()->IsCompressible()) {
       // TODO(solanes): Teach TurboFan/CSA to not bailout to the runtime to
       // avoid this call.
       return reinterpret_cast<const uint8_t*>(resource()->cached_data());
@@ -940,7 +940,7 @@ DEF_GETTER(ExternalTwoByteString, mutable_resource,
 void ExternalTwoByteString::update_data_cache(Isolate* isolate) {
   DisallowGarbageCollection no_gc;
   if (is_uncached()) {
-    if (resource()->IsCacheable()) mutable_resource()->UpdateDataCache();
+    if (!resource()->IsCompressible()) mutable_resource()->UpdateDataCache();
   } else {
     WriteExternalPointerField(kResourceDataOffset, isolate,
                               reinterpret_cast<Address>(resource()->data()),
@@ -968,7 +968,7 @@ void ExternalTwoByteString::set_resource(
 const uint16_t* ExternalTwoByteString::GetChars() {
   DisallowGarbageCollection no_gc;
   if (is_uncached()) {
-    if (resource()->IsCacheable()) {
+    if (!resource()->IsCompressible()) {
       // TODO(solanes): Teach TurboFan/CSA to not bailout to the runtime to
       // avoid this call.
       return resource()->cached_data();
diff --git a/src/objects/string.cc b/src/objects/string.cc
index b9413618ee..90e336acd8 100644
--- a/src/objects/string.cc
+++ b/src/objects/string.cc
@@ -144,7 +144,7 @@ bool String::MakeExternal(v8::String::ExternalStringResource* resource) {
   // Externalizing twice leaks the external resource, so it's
   // prohibited by the API.
   DCHECK(this->SupportsExternalization());
-  DCHECK(resource->IsCacheable());
+  DCHECK(!resource->IsCompressible());
 #ifdef ENABLE_SLOW_DCHECKS
   if (FLAG_enable_slow_asserts) {
     // Assert that the resource and the string are equivalent.
@@ -217,7 +217,7 @@ bool String::MakeExternal(v8::String::ExternalOneByteStringResource* resource) {
   // Externalizing twice leaks the external resource, so it's
   // prohibited by the API.
   DCHECK(this->SupportsExternalization());
-  DCHECK(resource->IsCacheable());
+  DCHECK(!resource->IsCompressible());
 #ifdef ENABLE_SLOW_DCHECKS
   if (FLAG_enable_slow_asserts) {
     // Assert that the resource and the string are equivalent.
diff --git a/src/parsing/scanner-character-streams.cc b/src/parsing/scanner-character-streams.cc
index 7eedc0c05c..aa637a9105 100644
--- a/src/parsing/scanner-character-streams.cc
+++ b/src/parsing/scanner-character-streams.cc
@@ -18,33 +18,6 @@
 namespace v8 {
 namespace internal {
 
-class V8_NODISCARD ScopedExternalStringLock {
- public:
-  explicit ScopedExternalStringLock(ExternalString string) {
-    DCHECK(!string.is_null());
-    if (string.IsExternalOneByteString()) {
-      resource_ = ExternalOneByteString::cast(string).resource();
-    } else {
-      DCHECK(string.IsExternalTwoByteString());
-      resource_ = ExternalTwoByteString::cast(string).resource();
-    }
-    DCHECK(resource_);
-    resource_->Lock();
-  }
-
-  // Copying a lock increases the locking depth.
-  ScopedExternalStringLock(const ScopedExternalStringLock& other) V8_NOEXCEPT
-      : resource_(other.resource_) {
-    resource_->Lock();
-  }
-
-  ~ScopedExternalStringLock() { resource_->Unlock(); }
-
- private:
-  // Not nullptr.
-  const v8::String::ExternalStringResourceBase* resource_;
-};
-
 namespace {
 const unibrow::uchar kUtf8Bom = 0xFEFF;
 }  // namespace
@@ -99,13 +72,11 @@ class ExternalStringStream {
  public:
   ExternalStringStream(ExternalString string, size_t start_offset,
                        size_t length)
-      : lock_(string),
-        data_(string.GetChars() + start_offset),
+      : data_(string.GetChars() + start_offset),
         length_(length) {}
 
   ExternalStringStream(const ExternalStringStream& other) V8_NOEXCEPT
-      : lock_(other.lock_),
-        data_(other.data_),
+      : data_(other.data_),
         length_(other.length_) {}
 
   // The no_gc argument is only here because of the templated way this class
@@ -119,7 +90,6 @@ class ExternalStringStream {
   static const bool kCanAccessHeap = false;
 
  private:
-  ScopedExternalStringLock lock_;
   const Char* const data_;
   const size_t length_;
 };
diff --git a/src/snapshot/snapshot.cc b/src/snapshot/snapshot.cc
index 360bddc4b9..309ea80a98 100644
--- a/src/snapshot/snapshot.cc
+++ b/src/snapshot/snapshot.cc
@@ -623,11 +623,11 @@ bool RunExtraCode(v8::Isolate* isolate, v8::Local<v8::Context> context,
   v8::Context::Scope context_scope(context);
   v8::TryCatch try_catch(isolate);
   v8::Local<v8::String> source_string;
-  if (!v8::String::NewFromUtf8(isolate, utf8_source).ToLocal(&source_string)) {
+  if (!v8::String::NewFromUtf8(isolate, utf8_source, v8::NewStringType::kNormal).ToLocal(&source_string)) {
     return false;
   }
   v8::Local<v8::String> resource_name =
-      v8::String::NewFromUtf8(isolate, name).ToLocalChecked();
+      v8::String::NewFromUtf8(isolate, name, v8::NewStringType::kNormal).ToLocalChecked();
   v8::ScriptOrigin origin(isolate, resource_name);
   v8::ScriptCompiler::Source source(source_string, origin);
   v8::Local<v8::Script> script;
