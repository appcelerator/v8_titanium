From 9565ef6f8fefcfea838f73f5ff57e5587d9bd059 Mon Sep 17 00:00:00 2001
From: Gary Mathews <gmathews@appcelerator.com>
Date: Wed, 19 Sep 2018 17:25:01 +0300
Subject: [PATCH] Titanium 7.X.X compatibility

---
 include/v8.h      | 101 +++++++++++++++++++++++++++++++++--
 src/api.cc        | 157 ++++++++++++++++++++++++++++++++++++++++++++++++++----
 src/objects-inl.h |  10 ++++
 src/objects.h     |   4 ++
 4 files changed, 259 insertions(+), 13 deletions(-)

diff --git a/include/v8.h b/include/v8.h
index 63edc67edf..c0d4e6f0e2 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -1356,12 +1356,18 @@ class V8_EXPORT Script {
       Local<Context> context, Local<String> source,
       ScriptOrigin* origin = nullptr);
 
+  static Local<Script> Compile(v8::Local<String> source,
+                        v8::ScriptOrigin* origin);
+  static Local<Script> Compile(v8::Local<String> source,
+                        v8::Local<String> file_name);
+
   /**
    * Runs the script returning the resulting value. It will be run in the
    * context in which it was created (ScriptCompiler::CompileBound or
    * UnboundScript::BindToCurrentContext()).
    */
   V8_WARN_UNUSED_RESULT MaybeLocal<Value> Run(Local<Context> context);
+  Local<Value> Run();
 
   /**
    * Returns the corresponding context-unbound script.
@@ -1727,6 +1733,7 @@ class V8_EXPORT Message {
 
   V8_WARN_UNUSED_RESULT MaybeLocal<String> GetSourceLine(
       Local<Context> context) const;
+  Local<String> GetSourceLine() const;
 
   /**
    * Returns the origin for the script from where the function causing the
@@ -1751,6 +1758,7 @@ class V8_EXPORT Message {
    * Returns the number, 1-based, of the line where the error occurred.
    */
   V8_WARN_UNUSED_RESULT Maybe<int> GetLineNumber(Local<Context> context) const;
+  int GetLineNumber() const;
 
   /**
    * Returns the index within the script of the first character where
@@ -1830,6 +1838,7 @@ class V8_EXPORT StackTrace {
    * Returns a StackFrame at a particular index.
    */
   Local<StackFrame> GetFrame(Isolate* isolate, uint32_t index) const;
+  Local<StackFrame> GetFrame(uint32_t index) const;
 
   /**
    * Returns the number of StackFrames.
@@ -2537,6 +2546,8 @@ class V8_EXPORT Value : public Data {
   V8_DEPRECATE_SOON("Use maybe version",
                     Local<Int32> ToInt32(Isolate* isolate) const);
 
+  Local<String> ToString() const;
+
   /**
    * Attempts to convert a string to an array index.
    * Returns an empty handle if the conversion fails.
@@ -2552,6 +2563,9 @@ class V8_EXPORT Value : public Data {
       Local<Context> context) const;
   V8_WARN_UNUSED_RESULT Maybe<int32_t> Int32Value(Local<Context> context) const;
 
+  bool BooleanValue() const;
+  int32_t Int32Value() const;
+
   /** JS == */
   V8_WARN_UNUSED_RESULT Maybe<bool> Equals(Local<Context> context,
                                            Local<Value> that) const;
@@ -2721,6 +2735,8 @@ class V8_EXPORT String : public Name {
   // UTF-8 encoded characters.
   int WriteUtf8(Isolate* isolate, char* buffer, int length = -1,
                 int* nchars_ref = NULL, int options = NO_OPTIONS) const;
+  int WriteUtf8(char* buffer, int length = -1, int* nchars_ref = NULL,
+                int options = NO_OPTIONS) const;
 
   /**
    * A zero length string.
@@ -2882,6 +2898,7 @@ class V8_EXPORT String : public Name {
    * Creates a new string by concatenating the left and the right strings
    * passed in as parameters.
    */
+  static Local<String> Concat(Local<String> left, Local<String> right);
   static Local<String> Concat(Isolate* isolate, Local<String> left,
                               Local<String> right);
 
@@ -2952,6 +2969,7 @@ class V8_EXPORT String : public Name {
    */
   class V8_EXPORT Utf8Value {
    public:
+    Utf8Value(Local<v8::Value> obj);
     Utf8Value(Isolate* isolate, Local<v8::Value> obj);
     ~Utf8Value();
     char* operator*() { return str_; }
@@ -2975,6 +2993,7 @@ class V8_EXPORT String : public Name {
    */
   class V8_EXPORT Value {
    public:
+    Value(Local<v8::Value> obj);
     Value(Isolate* isolate, Local<v8::Value> obj);
     ~Value();
     uint16_t* operator*() { return str_; }
@@ -3412,6 +3431,12 @@ class V8_EXPORT Object : public Value {
   /**
    * Note: SideEffectType affects the getter only, not the setter.
    */
+  bool SetAccessor(Local<Name> name,
+      AccessorNameGetterCallback getter,
+      AccessorNameSetterCallback setter = 0,
+      Local<Value> data = Local<Value>(),
+      AccessControl settings = DEFAULT,
+      PropertyAttribute attribute = None);
   V8_WARN_UNUSED_RESULT Maybe<bool> SetAccessor(
       Local<Context> context, Local<Name> name,
       AccessorNameGetterCallback getter, AccessorNameSetterCallback setter = 0,
@@ -3579,6 +3604,8 @@ class V8_EXPORT Object : public Value {
                                                    Local<Name> key);
   V8_WARN_UNUSED_RESULT Maybe<bool> HasOwnProperty(Local<Context> context,
                                                    uint32_t index);
+  bool HasOwnProperty(Local<String> key);
+
   V8_DEPRECATE_SOON("Use maybe version",
                     bool HasRealNamedProperty(Local<String> key));
   /**
@@ -3626,6 +3653,7 @@ class V8_EXPORT Object : public Value {
    * in the prototype chain.
    * This means interceptors in the prototype chain are not called.
    */
+  Local<Value> GetRealNamedProperty(Local<String> key);
   V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedProperty(
       Local<Context> context, Local<Name> key);
 
@@ -3877,6 +3905,7 @@ class FunctionCallbackInfo {
   V8_INLINE int Length() const;
   /** Accessor for the available arguments. */
   V8_INLINE Local<Value> operator[](int i) const;
+  V8_INLINE Local<Function> Callee() const;
   /** Returns the receiver. This corresponds to the "this" value. */
   V8_INLINE Local<Object> This() const;
   /**
@@ -3913,6 +3942,7 @@ class FunctionCallbackInfo {
   static const int kReturnValueIndex = 3;
   static const int kDataIndex = 4;
   static const int kNewTargetIndex = 5;
+  static const int kCalleeIndex = 6;
 
   V8_INLINE FunctionCallbackInfo(internal::Object** implicit_args,
                                  internal::Object** values, int length);
@@ -4065,6 +4095,8 @@ class V8_EXPORT Function : public Object {
     return NewInstance(context, 0, nullptr);
   }
 
+  Local<Object> NewInstance(int argc, Local<Value> argv[]) const;
+
   /**
    * When side effect checks are enabled, passing kHasNoSideEffect allows the
    * constructor to be invoked without throwing. Calls made within the
@@ -5415,6 +5447,54 @@ class V8_EXPORT Template : public Data {
   friend class FunctionTemplate;
 };
 
+
+/**
+ * NamedProperty[Getter|Setter] are used as interceptors on object.
+ * See ObjectTemplate::SetNamedPropertyHandler.
+ */
+typedef void (*NamedPropertyGetterCallback)(
+    Local<String> property,
+    const PropertyCallbackInfo<Value>& info);
+
+
+/**
+ * Returns the value if the setter intercepts the request.
+ * Otherwise, returns an empty handle.
+ */
+typedef void (*NamedPropertySetterCallback)(
+    Local<String> property,
+    Local<Value> value,
+    const PropertyCallbackInfo<Value>& info);
+
+
+/**
+ * Returns a non-empty handle if the interceptor intercepts the request.
+ * The result is an integer encoding property attributes (like v8::None,
+ * v8::DontEnum, etc.)
+ */
+typedef void (*NamedPropertyQueryCallback)(
+    Local<String> property,
+    const PropertyCallbackInfo<Integer>& info);
+
+
+/**
+ * Returns a non-empty handle if the deleter intercepts the request.
+ * The return value is true if the property could be deleted and false
+ * otherwise.
+ */
+typedef void (*NamedPropertyDeleterCallback)(
+    Local<String> property,
+    const PropertyCallbackInfo<Boolean>& info);
+
+/**
+ * Returns an array containing the names of the properties the named
+ * property getter intercepts.
+ *
+ * Note: The values in the array must be of type v8::Name.
+ */
+typedef void (*NamedPropertyEnumeratorCallback)(
+    const PropertyCallbackInfo<Array>& info);
+
 // TODO(dcarney): Replace GenericNamedPropertyFooCallback with just
 // NamedPropertyFooCallback.
 
@@ -5763,8 +5843,7 @@ class V8_EXPORT FunctionTemplate : public Template {
       Isolate* isolate, FunctionCallback callback = 0,
       Local<Value> data = Local<Value>(),
       Local<Signature> signature = Local<Signature>(), int length = 0,
-      ConstructorBehavior behavior = ConstructorBehavior::kAllow,
-      SideEffectType side_effect_type = SideEffectType::kHasSideEffect);
+      ConstructorBehavior behavior = ConstructorBehavior::kAllow);
 
   /** Get a template included in the snapshot by index. */
   static MaybeLocal<FunctionTemplate> FromSnapshot(Isolate* isolate,
@@ -6119,8 +6198,15 @@ class V8_EXPORT ObjectTemplate : public Template {
       Local<Name> name, AccessorNameGetterCallback getter,
       AccessorNameSetterCallback setter = 0, Local<Value> data = Local<Value>(),
       AccessControl settings = DEFAULT, PropertyAttribute attribute = None,
-      Local<AccessorSignature> signature = Local<AccessorSignature>(),
-      SideEffectType getter_side_effect_type = SideEffectType::kHasSideEffect);
+      Local<AccessorSignature> signature = Local<AccessorSignature>());
+
+  void SetNamedPropertyHandler(
+      NamedPropertyGetterCallback getter,
+      NamedPropertySetterCallback setter = 0,
+      NamedPropertyQueryCallback query = 0,
+      NamedPropertyDeleterCallback deleter = 0,
+      NamedPropertyEnumeratorCallback enumerator = 0,
+      Local<Value> data = Local<Value>());
 
   /**
    * Sets a named property handler on the object template.
@@ -8795,6 +8881,7 @@ class V8_EXPORT TryCatch {
    * all TryCatch blocks should be stack allocated because the memory
    * location itself is compared against JavaScript try/catch blocks.
    */
+  explicit TryCatch();
   explicit TryCatch(Isolate* isolate);
 
   /**
@@ -8854,6 +8941,7 @@ class V8_EXPORT TryCatch {
    */
   V8_WARN_UNUSED_RESULT MaybeLocal<Value> StackTrace(
       Local<Context> context) const;
+  Local<Value> StackTrace() const;
 
   /**
    * Returns the message associated with this exception.  If there is
@@ -9885,6 +9973,11 @@ Local<Value> FunctionCallbackInfo<T>::operator[](int i) const {
   return Local<Value>(reinterpret_cast<Value*>(values_ - i));
 }
 
+template<typename T>
+Local<Function> FunctionCallbackInfo<T>::Callee() const {
+  return Local<Function>(reinterpret_cast<Function*>(
+      &implicit_args_[kCalleeIndex]));
+}
 
 template<typename T>
 Local<Object> FunctionCallbackInfo<T>::This() const {
diff --git a/src/api.cc b/src/api.cc
index d141496c57..d821646237 100644
--- a/src/api.cc
+++ b/src/api.cc
@@ -219,6 +219,10 @@ Local<Context> ContextFromNeverReadOnlySpaceObject(
   return reinterpret_cast<v8::Isolate*>(obj->GetIsolate())->GetCurrentContext();
 }
 
+Local<Context> ContextFromHeapObject(i::Handle<i::Object> obj) {
+  return reinterpret_cast<v8::Isolate*>(i::HeapObject::cast(*obj)->GetIsolate())->GetCurrentContext();
+}
+
 class InternalEscapableScope : public v8::EscapableHandleScope {
  public:
   explicit inline InternalEscapableScope(i::Isolate* isolate)
@@ -1410,15 +1414,14 @@ static Local<FunctionTemplate> FunctionTemplateNew(
 
 Local<FunctionTemplate> FunctionTemplate::New(
     Isolate* isolate, FunctionCallback callback, v8::Local<Value> data,
-    v8::Local<Signature> signature, int length, ConstructorBehavior behavior,
-    SideEffectType side_effect_type) {
+    v8::Local<Signature> signature, int length, ConstructorBehavior behavior) {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
   // Changes to the environment cannot be captured in the snapshot. Expect no
   // function templates when the isolate is created for serialization.
   LOG_API(i_isolate, FunctionTemplate, New);
   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
   auto templ = FunctionTemplateNew(i_isolate, callback, data, signature, length,
-                                   false, Local<Private>(), side_effect_type);
+                                   false, Local<Private>(), SideEffectType::kHasSideEffect);
   if (behavior == ConstructorBehavior::kThrow) templ->RemovePrototype();
   return templ;
 }
@@ -1748,11 +1751,10 @@ void ObjectTemplate::SetAccessor(v8::Local<Name> name,
                                  AccessorNameSetterCallback setter,
                                  v8::Local<Value> data, AccessControl settings,
                                  PropertyAttribute attribute,
-                                 v8::Local<AccessorSignature> signature,
-                                 SideEffectType getter_side_effect_type) {
+                                 v8::Local<AccessorSignature> signature) {
   TemplateSetAccessor(this, name, getter, setter, data, settings, attribute,
                       signature, i::FLAG_disable_old_api_accessors, false,
-                      getter_side_effect_type);
+                      SideEffectType::kHasSideEffect);
 }
 
 template <typename Getter, typename Setter, typename Query, typename Descriptor,
@@ -1835,6 +1837,15 @@ static void ObjectTemplateSetNamedPropertyHandler(
   cons->set_named_property_handler(*obj);
 }
 
+void ObjectTemplate::SetNamedPropertyHandler(
+    NamedPropertyGetterCallback getter, NamedPropertySetterCallback setter,
+    NamedPropertyQueryCallback query, NamedPropertyDeleterCallback remover,
+    NamedPropertyEnumeratorCallback enumerator, Local<Value> data) {
+  ObjectTemplateSetNamedPropertyHandler(
+      this, getter, setter, query, nullptr, remover, enumerator, nullptr, data,
+      PropertyHandlerFlags::kOnlyInterceptStrings);
+}
+
 void ObjectTemplate::SetHandler(
     const NamedPropertyHandlerConfiguration& config) {
   ObjectTemplateSetNamedPropertyHandler(
@@ -2119,6 +2130,16 @@ MaybeLocal<Value> Script::Run(Local<Context> context) {
 }
 
 
+Local<Value> Script::Run() {
+  auto self = Utils::OpenHandle(this, true);
+  // If execution is terminating, Compile(..)->Run() requires this
+  // check.
+  if (self.is_null()) return Local<Value>();
+  auto context = ContextFromHeapObject(self);
+  RETURN_TO_LOCAL_UNCHECKED(Run(context), Value);
+}
+
+
 Local<Value> ScriptOrModule::GetResourceName() {
   i::Handle<i::Script> obj = Utils::OpenHandle(this);
   i::Isolate* isolate = obj->GetIsolate();
@@ -2618,9 +2639,42 @@ MaybeLocal<Script> Script::Compile(Local<Context> context, Local<String> source,
   return ScriptCompiler::Compile(context, &script_source);
 }
 
+Local<Script> Script::Compile(v8::Local<String> source,
+                              v8::ScriptOrigin* origin) {
+  auto str = Utils::OpenHandle(*source);
+  auto context = ContextFromHeapObject(str);
+  RETURN_TO_LOCAL_UNCHECKED(Compile(context, source, origin), Script);
+}
+
+
+Local<Script> Script::Compile(v8::Local<String> source,
+                              v8::Local<String> file_name) {
+  auto str = Utils::OpenHandle(*source);
+  auto context = ContextFromHeapObject(str);
+  ScriptOrigin origin(file_name);
+  return Compile(context, source, &origin).FromMaybe(Local<Script>());
+}
+
 
 // --- E x c e p t i o n s ---
 
+v8::TryCatch::TryCatch()
+    : isolate_(i::Isolate::Current()),
+      next_(isolate_->try_catch_handler()),
+      is_verbose_(false),
+      can_continue_(true),
+      capture_message_(true),
+      rethrow_(false),
+      has_terminated_(false) {
+  ResetInternal();
+  // Special handling for simulators which have a separate JS stack.
+  js_stack_comparable_address_ =
+      reinterpret_cast<void*>(i::SimulatorStack::RegisterCTryCatch(
+          isolate_, i::GetCurrentStackPosition()));
+  isolate_->RegisterTryCatchHandler(this);
+}
+
+
 v8::TryCatch::TryCatch(v8::Isolate* isolate)
     : isolate_(reinterpret_cast<i::Isolate*>(isolate)),
       next_(isolate_->try_catch_handler()),
@@ -2724,6 +2778,12 @@ MaybeLocal<Value> v8::TryCatch::StackTrace(Local<Context> context) const {
 }
 
 
+v8::Local<Value> v8::TryCatch::StackTrace() const {
+  auto context = reinterpret_cast<v8::Isolate*>(isolate_)->GetCurrentContext();
+  RETURN_TO_LOCAL_UNCHECKED(StackTrace(context), Value);
+}
+
+
 v8::Local<v8::Message> v8::TryCatch::Message() const {
   i::Object* message = reinterpret_cast<i::Object*>(message_obj_);
   DCHECK(message->IsJSMessageObject() || message->IsTheHole(isolate_));
@@ -2817,6 +2877,11 @@ Maybe<int> Message::GetLineNumber(Local<Context> context) const {
   return Just(msg->GetLineNumber());
 }
 
+int Message::GetLineNumber() const {
+  auto context = ContextFromHeapObject(Utils::OpenHandle(this));
+  return GetLineNumber(context).FromMaybe(0);
+}
+
 
 int Message::GetStartPosition() const {
   auto self = Utils::OpenHandle(this);
@@ -2891,6 +2956,12 @@ MaybeLocal<String> Message::GetSourceLine(Local<Context> context) const {
 }
 
 
+Local<String> Message::GetSourceLine() const {
+  auto context = ContextFromHeapObject(Utils::OpenHandle(this));
+  RETURN_TO_LOCAL_UNCHECKED(GetSourceLine(context), String)
+}
+
+
 void Message::PrintCurrentStackTrace(Isolate* isolate, FILE* out) {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
@@ -2910,6 +2981,11 @@ Local<StackFrame> StackTrace::GetFrame(Isolate* v8_isolate,
   return scope.Escape(Utils::StackFrameToLocal(info));
 }
 
+Local<StackFrame> StackTrace::GetFrame(uint32_t index) const {
+  Isolate* isolate = reinterpret_cast<v8::Isolate*>(i::HeapObject::cast(*Utils::OpenHandle(this))->GetIsolate());
+  return GetFrame(isolate, index);
+}
+
 int StackTrace::GetFrameCount() const {
   return Utils::OpenHandle(this)->length();
 }
@@ -3521,6 +3597,10 @@ Local<String> Value::ToString(Isolate* isolate) const {
   RETURN_TO_LOCAL_UNCHECKED(ToString(isolate->GetCurrentContext()), String);
 }
 
+Local<String> Value::ToString() const {
+  return ToString(Isolate::GetCurrent()->GetCurrentContext()).FromMaybe(Local<String>());
+}
+
 
 MaybeLocal<String> Value::ToDetailString(Local<Context> context) const {
   i::Handle<i::Object> obj = Utils::OpenHandle(this);
@@ -3882,6 +3962,12 @@ Maybe<bool> Value::BooleanValue(Local<Context> context) const {
 }
 
 
+bool Value::BooleanValue() const {
+  auto context = reinterpret_cast<v8::Isolate*>(i::HeapObject::cast(*Utils::OpenHandle(this))->GetIsolate())->GetCurrentContext();
+  return BooleanValue(context).FromMaybe(false);
+}
+
+
 Maybe<double> Value::NumberValue(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsNumber()) return Just(obj->Number());
@@ -3924,6 +4010,14 @@ Maybe<int32_t> Value::Int32Value(Local<Context> context) const {
 }
 
 
+int32_t Value::Int32Value() const {
+  auto obj = Utils::OpenHandle(this);
+  if (obj->IsNumber()) return NumberToInt32(*obj);
+  auto context = reinterpret_cast<v8::Isolate*>(i::HeapObject::cast(*obj)->GetIsolate())->GetCurrentContext();
+  return Int32Value(context).FromMaybe(0);
+}
+
+
 Maybe<uint32_t> Value::Uint32Value(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (obj->IsNumber()) return Just(NumberToUint32(*obj));
@@ -4613,6 +4707,17 @@ Maybe<bool> Object::SetAccessor(Local<Context> context, Local<Name> name,
 }
 
 
+bool Object::SetAccessor(Local<Name> name, AccessorNameGetterCallback getter,
+                         AccessorNameSetterCallback setter,
+                         v8::Local<Value> data, AccessControl settings,
+                         PropertyAttribute attribute) {
+  auto context = ContextFromHeapObject(Utils::OpenHandle(this));
+  return ObjectSetAccessor(context, this, name, getter, setter,
+                           data, settings, attribute, i::FLAG_disable_old_api_accessors,
+                           false, SideEffectType::kHasSideEffect).FromMaybe(false);
+}
+
+
 void Object::SetAccessorProperty(Local<Name> name, Local<Function> getter,
                                  Local<Function> setter,
                                  PropertyAttribute attribute,
@@ -4675,6 +4780,11 @@ Maybe<bool> v8::Object::HasOwnProperty(Local<Context> context, uint32_t index) {
   return result;
 }
 
+bool v8::Object::HasOwnProperty(Local<String> key) {
+  auto context = ContextFromHeapObject(Utils::OpenHandle(this));
+  return HasOwnProperty(context, key).FromMaybe(false);
+}
+
 Maybe<bool> v8::Object::HasRealNamedProperty(Local<Context> context,
                                              Local<Name> key) {
   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());
@@ -4818,6 +4928,12 @@ MaybeLocal<Value> v8::Object::GetRealNamedProperty(Local<Context> context,
 }
 
 
+Local<Value> v8::Object::GetRealNamedProperty(Local<String> key) {
+  auto context = ContextFromHeapObject(Utils::OpenHandle(this));
+  RETURN_TO_LOCAL_UNCHECKED(GetRealNamedProperty(context, key), Value);
+}
+
+
 Maybe<PropertyAttribute> v8::Object::GetRealNamedPropertyAttributes(
     Local<Context> context, Local<Name> key) {
   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());
@@ -4939,6 +5055,12 @@ MaybeLocal<Object> Function::NewInstance(Local<Context> context, int argc,
                                        SideEffectType::kHasSideEffect);
 }
 
+Local<v8::Object> Function::NewInstance(int argc,
+                                        v8::Local<v8::Value> argv[]) const {
+  auto context = ContextFromHeapObject(Utils::OpenHandle(this));
+  RETURN_TO_LOCAL_UNCHECKED(NewInstance(context, argc, argv), Object);
+}
+
 MaybeLocal<Object> Function::NewInstanceWithSideEffectType(
     Local<Context> context, int argc, v8::Local<v8::Value> argv[],
     SideEffectType side_effect_type) const {
@@ -5563,6 +5686,11 @@ int String::WriteUtf8(Isolate* v8_isolate, char* buffer, int capacity,
   return writer.CompleteWrite(write_null, nchars_ref);
 }
 
+int String::WriteUtf8(char* buffer, int capacity, int* nchars_ref, int options) const {
+  auto isolate = reinterpret_cast<v8::Isolate*>(i::HeapObject::cast(*Utils::OpenHandle(this))->GetIsolate());
+  return WriteUtf8(isolate, buffer, capacity, nchars_ref, options);
+}
+
 template <typename CharType>
 static inline int WriteHelper(i::Isolate* isolate, const String* string,
                               CharType* buffer, int start, int length,
@@ -6549,6 +6677,11 @@ Local<String> v8::String::Concat(Isolate* v8_isolate, Local<String> left,
   return Utils::ToLocal(result);
 }
 
+Local<String> v8::String::Concat(Local<String> left, Local<String> right) {
+  Isolate* isolate = reinterpret_cast<Isolate*>(Utils::OpenHandle(*left)->GetIsolate());
+  return Concat(isolate, left, right);
+}
+
 MaybeLocal<String> v8::String::NewExternalTwoByte(
     Isolate* isolate, v8::String::ExternalStringResource* resource) {
   CHECK(resource && resource->data());
@@ -8908,6 +9041,9 @@ String::Utf8Value::Utf8Value(v8::Isolate* isolate, v8::Local<v8::Value> obj)
   str->WriteUtf8(isolate, str_);
 }
 
+String::Utf8Value::Utf8Value(v8::Local<v8::Value> obj)
+    : String::Utf8Value::Utf8Value(Isolate::GetCurrent(), obj) {}
+
 String::Utf8Value::~Utf8Value() {
   i::DeleteArray(str_);
 }
@@ -8927,6 +9063,9 @@ String::Value::Value(v8::Isolate* isolate, v8::Local<v8::Value> obj)
   str->Write(isolate, str_);
 }
 
+String::Value::Value(v8::Local<v8::Value> obj)
+    : String::Value::Value(v8::Isolate::GetCurrent(), obj) {}
+
 String::Value::~Value() {
   i::DeleteArray(str_);
 }
diff --git a/src/objects-inl.h b/src/objects-inl.h
index 05b2b9653f..532d6021ee 100644
--- a/src/objects-inl.h
+++ b/src/objects-inl.h
@@ -878,6 +878,16 @@ Heap* NeverReadOnlySpaceObject::GetHeap() const {
   return heap;
 }
 
+Heap* HeapObject::GetHeap() const {
+  Heap* heap = MemoryChunk::FromAddress(reinterpret_cast<Address>(const_cast<HeapObject*>(this)))->heap();
+  SLOW_DCHECK(heap != nullptr);
+  return heap;
+}
+
+Isolate* HeapObject::GetIsolate() const {
+  return GetHeap()->isolate();
+}
+
 Isolate* NeverReadOnlySpaceObject::GetIsolate() const {
   return GetHeap()->isolate();
 }
diff --git a/src/objects.h b/src/objects.h
index c848e92af7..6d7f8ba882 100644
--- a/src/objects.h
+++ b/src/objects.h
@@ -1671,6 +1671,10 @@ class HeapObject: public Object {
   // places where it might not be safe to access it.
   inline ReadOnlyRoots GetReadOnlyRoots() const;
 
+  // Convenience method to get current isolate.
+  inline Heap* GetHeap() const;
+  inline Isolate* GetIsolate() const;
+
 #define IS_TYPE_FUNCTION_DECL(Type) V8_INLINE bool Is##Type() const;
   HEAP_OBJECT_TYPE_LIST(IS_TYPE_FUNCTION_DECL)
 #undef IS_TYPE_FUNCTION_DECL
-- 
2.15.2 (Apple Git-101.1)

